---
layout: post
title: 密码管理器的进化史
date: 2022-06-21 22:27 +0800
categories: [Bottom Layer Knowledge] 
tags: [Architecture Design,安全/权限控制]
math: true
---

主要从密码管理器保护密码的安全性角度，分享一下相关的专业知识。因密码管理器涉及很多方面的知识，本系列文章只讨论数据加密保护。

# 密码管理器历史
## 第一代密码管理器
### 技术架构

- **安全技术**：有管理，无保护
- **典型代表**：小本子、记事本、浏览器集成的密码管理器和一些私密云笔记

众所周知，互联网服务越来越流行，需要登录的网站不断增多，需要记住的密码快速增加。

但是，密码设置要求要复杂，包含数字、字母、符号等；不能使用相同密码。于是，人们开始尝试各种管理密码的方法，有人用小本子记、有人用记事本保存到文件。同时，云笔记开始流行，还能写私密笔记，只需设置一个密码，就能随时同步。

我们使用浏览器上网，需要经常输入用户名和密码，浏览器就集成记密码和填充密码的功能。

![chrome 记住密码](https://cdn.jsdelivr.net/gh/Optimus-Xs/Blog-Images/2022-06-21-the-evolution-of-password-managers%2Fchrome-remember-password.png)

第一代密码管理器通常都没加密，换句话说，这和你用记事本（记密码）保存在电脑上差不多。

不过，其最大的问题在于：密码明文集中保存。浏览器厂商也知道这个问题很严重，慢慢开始加密保存。不过，这并没有什么卵用。

比如，Chrome 浏览器在 Windows 上使用 DPAPI 加密，用户打开任何其他程序都可以调用 CryptUnprotectData 解密来获得密码。

> 一个 Chrome 密码被盗的案例: [【差评】臭代码摆烂十年没人修！黑客一秒盗走了我的密码，这个浏览器功能缺陷“劳苦功高”！](https://www.bilibili.com/video/BV1vP411T7Wc/) 

> DPAPI 是什么？
> 
> DPAPI 是 Windows 操作系统内置的一项数据加密服务。它的核心特点是将数据加密与用户或计算机本身绑定。这意味着：
> 
> - 只有当前登录的用户账户才能解密由该账户加密的数据。
> - 数据在特定计算机上加密后，通常只能在该计算机上解密。
> 
> Chrome 浏览器正是利用了这一特性，用 DPAPI 加密了你的登录信息。当你在 Windows 电脑上保存密码时，这些密码不会以明文形式存储，而是通过 DPAPI 加密后保存在你的本地配置文件中。当你需要使用这些密码时，Chrome 会调用 DPAPI 来解密它们。
>
> 然而，它无法抵御针对你Windows 用户账户的攻击或高阶恶意软件的内存窃取, 如果你的 Windows 账户被恶意软件或攻击者控制，攻击者就可以以你的身份登录并调用 DPAPI 来解密你的所有保存密码
{: .prompt-info }

> 为了解决这个问题, 从 Chrome 127 开始，为了更好地保护 **Passkeys（通行密钥）**这类高度敏感的数据，Chrome 在 Windows 上开始使用一种更强大的、真正“应用导向”的密钥生成和存储方式。
> 
> 这个新机制利用了 Windows 平台提供的更现代、更强大的 API，使得生成的密钥与特定的 Chrome 应用程序和特定的用户配置文件深度绑定。
>
> - **旧机制 (DPAPI + 熵)**： 就像一把锁，它的钥匙保存在你的电脑上，并且这把钥匙只适用于 Chrome 这个“锁匠”。但是，如果一个恶意程序能够假扮成这个锁匠，它仍然有可能使用这把钥匙。
> - **新机制 (Chrome 127)**： 这把钥匙不再是一个可以被复制或转移的文件。它更像是一个“硬件信物”，它被物理性地**绑定在 Chrome 应用本身**上。即使恶意程序窃取了你的整个用户配置文件，它也无法通过这个密钥进行解密。
{: .prompt-tip }

### 第一代安全技术总结

第一代密码管理器的安全技术特点：有管理，无保护。它根本没有加密保护，或很容易破解的简单加密保护。如果浏览器能直接读取保存的密码，那么其他应用程序也可以使用相同方法读取。

因此，如果浏览器能直接填充密码，而不要求输入独立的主密码解锁，那就没有真正的保护。

目前，浏览器还是黑客最主要的攻击目标之一，因此建议，不要使用浏览器自带的密码管理器。

众所周知，用记事本记密码很不安全，而输入密码才能查看的私密云笔记，却有很大的迷惑性，被很多用户误以为很安全。

一些云笔记仅仅使用密码限制用户访问，而不是使用密码加密笔记内容。如果云端被黑客入侵，那保存的密码就很可能被盗。

同时云笔记的开发者或者运维人员也可能用于笔记访问权

因此，使用云笔记保存密码要小心，除非确信设置的密码是用于加密内容。


## 第二代密码管理器
### 技术架构

- **安全技术**： 设置独立的主密码，端到端加密
- **安全问题**： 一旦主密码泄露，可能导致所有密码被盗

对密码这么重要的数据，第一代密码管理器实在不安全。为解决这个问题，2000 年左右，海外一些技术狂人和鬼才程序员已开始埋头苦干，奋力研究如何更好保护大家的密码。

从那时起，独立的专业密码管理器不断诞生，包括较知名的开源密码管理器：[Password Safe](https://www.pwsafe.org/)(since 2002) 和 [KeePass](https://keepass.info/)(since 2006)

第二代密码管理器带来真正的加密保护，有着独立的主密码。

密码管理器一般都使用对称加密算法，就是加密和解密都使用相同的密钥 `key`。

$cipher = encrypt(key, plain)$

$plain = decrypt(key, cipher)$

密码学设计认为：

- 加密算法 `encrypt/decrypt` 无法保密，黑客可以知道；
- 使用密钥` key` 可以很容易从密文 `cipher` 解密得到明文 `plain`（要保护的数据），没有 `key` 就不行；
- 要求保护好密钥 `key`，要求密钥 `key` 完全随机，防止黑客破解。

目前，最流行的对称加密算法是 AES(Advanced Encryption Standard)。根据密钥key的长度分为三个级别：128/192/256 bit。其中，AES-256 作为最高级别的算法，广泛应用于金融、军事等领域，也被很多密码管理器采用。

有些密码管理器宣称使用军事级别等加密技术，一般是指使用 AES-256 算法加密。

然而，并不是使用最高等级的加密算法，密码管理器就达到最高的安全水平。黑客通常不会破解加密算法，只会尝试获得密钥 `key`。

### 密钥生成

既然黑客最惦记密钥key，那关键就是怎样保护好密钥。一般来说，用户设置的主密码不能用作密钥key加密数据，不满足随机性要求。

比如，最低等级的 AES-128 要求至少 20 个完全随机的字符，没人能记住。

于是，密码学家们发明基于密码生成密钥的算法 PBKDF(Password-Based Key Derivation Function)，将密码转换成很长又完全随机的安全密钥，就可以加密数据。

目前，推荐的算法是 PBKDF2，而 brcypt、scrypt 等算法也有应用。

> PBKDF 不是一个简单的哈希函数。它通过一个被称为“加盐”（Salt）和“迭代”（Iteration）的复杂过程来生成密钥，这个过程是 PBKDF 算法的核心安全机制。
> 
> - 加盐（Salt）： 在计算密钥之前，PBKDF 会在用户的原始密码后面添加一个随机的、独一无二的数据串，这个数据串就是“盐”。
>   - 作用： 盐能防止攻击者使用预先计算好的哈希表（如彩虹表）进行攻击。即使两个用户使用了相同的弱密码，由于他们的“盐”不同，最终生成的密钥和哈希值也会完全不同。
> - 迭代（Iteration）： PBKDF 会重复地对加盐后的密码进行哈希运算，这个过程通常会执行成千上万次。
>   - 作用： 迭代的目的是故意让计算过程变慢。这对于普通用户来说，登录时只会感到轻微的延迟，但对于想要通过暴力破解来猜测密码的攻击者来说，数百万次的运算会耗费巨大的计算资源和时间，使其攻击成本呈指数级增长。
{: .prompt-tip }

尽管每个算法的具体细节不同，但基本原理都一样。如下，

$ Key = Hash(password, salt) $

这里的salt很关键，它完全随机。因此，即使通过很简单的密码，也能通过单向 Hash 函数计算出完全随机的key作为密钥，满足加密要求。

> salt 应该使用真随机数生成器(True Random Number Generator)生成
{: .prompt-tip }

用一句话来解释：通过主密码生成保护数据的安全密钥key

暴力破解

### 暴力破解

> 黑客是否可以使用暴力破解密码？

密码学算法都是公开的，黑客也能使用同样算法，不断尝试，总能算出那个相同的密钥 key，然后解密出数据原文。

为应对暴力破解，PBKDF 算法并不像普通的 Hash 算法那样快，相反它被故意设计成很慢（或者需要消耗较多计算资源）。

PBKDF 还可以设置迭代次数 count，开发者能根据当前计算机硬件水平选择合适的迭代次数。PBKDF 算法推荐设置为 10000 左右。

这样，黑客想暴力破解，消耗的计算资源也就增长 10000 倍。

不过，也不要将迭代次数 count 设置为 1000000，否则用户输入主密码时要计算很久。

用一句话解释：生成密钥的算法很消耗计算资源，这提高了暴力破解的难度。

### 核心算法

我们将前面的知识串起来，就是第二代密码管理器的核心算法设计。

1.设置主密码

![设置主密码](https://cdn.jsdelivr.net/gh/Optimus-Xs/Blog-Images/2022-06-21-the-evolution-of-password-managers%2Fgen2-set-main-password.jpeg)

用户设置主密码后，密码管理器通过 PBKDF2 生成了加密密钥 `key`，并且把参数 `salt` 和 `count` 保存起来 `KeyFile`。

- 密钥 `key` 用于加密数据，只在程序运行中使用，并不保存
- `KeyFile` 用于解锁时生成密钥 `key`

> 这里要强调，不保存主密码！不保存主密码！不保存主密码！
{: .prompt-danger }

用一句话解释：通过主密码生成安全的加密密钥 `key` ，并且保存密钥生成算法的参数。

2.加密数据

![加密数据](https://cdn.jsdelivr.net/gh/Optimus-Xs/Blog-Images/2022-06-21-the-evolution-of-password-managers%2Fgen2-encryption.jpeg)

加密后，把加密的参数 `IV(Initial Vector)` 和密文 `cipher` 一起保存下来 `CipherFile`。密钥 `key` 和被保护的数据明文 `plain` 不保存。

一句话解释：使用安全密钥加密数据，保存密文（加密后的数据）。

3.解密数据

![解密数据](https://cdn.jsdelivr.net/gh/Optimus-Xs/Blog-Images/2022-06-21-the-evolution-of-password-managers%2Fgen2-decryption.jpeg)

解密即把前面两个步骤反过来：

先从 `KeyFile` 中读取 PBKDF2 参数 `salt` 和 `count`，经过同样的计算得到密钥 `key`

再读取加密参数 `IV` 和 密文 `cipher`，使用 AES 解密算法得到原文 `plain`

用一句话解释：按照同样方法从主密码生成密钥 `key` ，再使用解密算法从密文解密出原文。

在实际应用中，每个密码管理器都可能做一些独特的设计和扩展。

比如不直接使用密码生成的密钥` key` 来加密保存的数据，而是加密另一个密钥 `key2`，再用 `key2` 来加密真正要保护的数据。

### 第二代安全技术总结

第二代密码管理器技术特点：

- 使用 PBKDF 算法，从主密码生成安全的密钥 `key`
- 使用高强度的加密算法（如 AES）加密数据
- 不以任何形式存储主密码

AES 加密算法本身很安全，但只要选取合适的密钥生成算法（如 PBKDF2） + 真正随机的 `salt` + 合理的迭代次数 `count`，第二代密码管理器就极难被破解，除非黑客能破解主密码。

相比第一代密码管理器，第二代密码管理器安全水平大大提升，只要保护好 主密码，就能保证数据安全。并且，第二代密码管理器使用主密码加密数据，真正提升了数据安全性，这是一个巨大进步。

保存密码，至少使用第二代密码管理器。

### 网络密码管理器

密码只需保存一次，即可自动同步所有终端设备，虽然方便，但也危险。

按照第二代密码管理器的方法设计，加上网络同步功能：

- 在设备 A 上创建主密码并保存 salt 和 count，加密数据；
- 通过网络/云服务，将保存的 salt、count 和加密后的数据同步到设备 B；
- 设备 B 上输入同样的主密码，有 salt、count 生成密钥，解密，查看保存数据；

这就是所谓的端到端加密（End-to-end Encryption）技术。你只能在终端设备上查看信息，而中间的传输网络无法解密。

> 如果网络密码管理器能重置主密码，那就要小心。
> 
> 是重置主密码，不是修改主密码
> 
> 既然加密密钥key只能通过主密码生成，在不提供主密码的情况下，服务提供商如何帮你重置密码？
> 
> 答案是服务提供商很可能帮你保管加密密钥。
{: .prompt-danger }

### 如何设置主密码

既然安全的关键是主密码，那怎样设置？

斯诺登建议使用密码短语(Passphrase)。本文建议使用一整句话作为主密码，比如

```
Space:thefinalfrontier.ThesearethevoyagesofthestarshipEnterprise.Itsfive-yearmission:toexplorestrangenewworlds;toseekoutnewlifeandnewcivilizations;toboldlygowherenomanhasgonebefore!
```

从暴力破解角度看，如果黑客不知道你的密码长度，通常会按照密码长度递增方式尝试破解。密码越长，暴力破解的计算资源越多，这也增加破解成本。

### 主密码的安全问题

想要第二代密码管理器能真正保护密码安全，主密码应满足两个条件：

- 足够长，足够强
- 不能被别人知道

遗憾的是，现实中它还是会遇到很多问题：

1. 主密码强度不够

    很多用户并知道主密码需要很高强度，也不知道怎样设置高强度的主密码。

2. 主密码被泄露

    例如在输主密码时，可能被不怀好意的人偷窥、被电梯摄像头录制下来、被设备上的恶意 App 录屏等等。

3. 主密码会被重用

    鉴于记忆密码太困难，以至于不少用户会重用主密码。重用主密码有很大的安全风险，一方面，这增加了其被偷窥的机会；另一方面，很多互联网服务安全性并不高，一旦某一个互联网服务泄露密码，那密码管理器的主密码就暴露了。

    即使是密码管理器厂商，也有可能被入侵，比如 [LastPass Security Notification](https://blog.lastpass.com/2011/05/lastpass-security-notification.html/) 、 [LastPass Hacked](https://blog.lastpass.com/2015/06/lastpass-security-notice.html/)。

    此外，互联网服务也会泄露密码。目前，已有很多互联网服务提供商泄露密码。[have i been pwned](https://haveibeenpwned.com/) 收集的泄露记录已超过地球人口总数，近 95 亿。

## 第三代密码管理器
### 技术架构

第三代密码管理器：主密码+主密钥保护

- **安全技术**: 增加主密钥保护，提升云端安全性
- **安全问题**: 设备终端安全性仍取决于主密码

通过云端同步时，第二代密码管理器离泄露所有密码只有“一个主密码的距离”。而主密码的安全问题并不能让人放心。于是，第三代密码管理器应运而生。说起第三代密码管理器，就不得不提 1Password，它们设计了一个 two-secret key derivation (2SKD)的方法来生成加密密钥。并且，它们还公开了[技术白皮书](https://1passwordstatic.com/files/security/1password-white-paper.pdf)。

> Two-Secret Key Derivation（2SKD）是 1Password 独有的一种密钥派生方法，它旨在进一步强化主加密密钥的生成过程，提供比传统 PBKDF2 算法更高的安全性。
> 
> 简单来说，2SKD 的核心思想是将两个独立的“秘密”结合起来，共同生成最终的加密密钥。这两个秘密分别是：
> 
> 你的主密码（`Master Password`）： 这是你记住并输入的密码。
> 
> 你的安全密钥（`Secret Key`）： 这是一个由 1Password 在你首次创建账户时生成的、长而随机的字符串。
>
> **2SKD 的工作原理:**
>
> 传统的 PBKDF2 算法只依赖于一个输入，即你的主密码，然后通过多次迭代和加盐来生成密钥。而 2SKD 的过程更复杂：
>
> - 第一步：基于主密码生成密钥
>   - 1Password 首先使用标准的 PBKDF2 算法，以你的主密码为输入，生成一个初步的密钥。这个过程的目的是通过迭代来抵抗暴力破解。
> - 第二步：基于安全密钥生成密钥
>   - 1Password 同时使用一个独立的、非常快速的算法（通常是一个哈希函数），以你的安全密钥为输入，生成另一个密钥。
> - 第三步：组合两个密钥
>   - 最后，将这两个独立的密钥通过加密学方法（如异或运算 XOR）组合起来，生成最终的、用于加密你所有保险库数据的主加密密钥。
>
> **2SKD 带来的安全优势:**
> 
> - 防范服务器端攻击： 即使 1Password 的服务器被攻破，并且攻击者拿到了你的加密数据和哈希化的主密码，他们仍然无法解密你的数据。因为他们没有你的安全密钥。这个密钥通常只存储在你的本地设备上，或通过你的应急工具箱（Emergency Kit）保存，从未被传输到 1Password 服务器上。
> - 防范网络钓鱼攻击： 如果你不幸在钓鱼网站上输入了你的主密码，攻击者也无法仅凭这个密码来解密你的数据。因为他们没有你的安全密钥，缺少了生成最终密钥的另一个关键部分。
> - 降低弱密码风险： 即使你使用了一个相对较弱的主密码，由于安全密钥是一个随机且无法猜测的字符串，它极大地增强了最终密钥的强度，使得暴力破解几乎不可能。
{: .prompt-info }


使用 1Password 的用户，除了要设置主密码外，还需要将一个主密钥 Secret Key 保存起来。

- 主密钥用于和主密码一起生成加密密钥
- 加密密钥通过主密码生成，用于加密数据的密钥

据悉，加拿大一家公司的产品 RememBear 采用类似技术，要求用户不仅要记住主密码，还要保存好 `New Device Key`。这只不过是给主密钥换了名字。

从算法角度讲，第三代密码管理器和第二代密码管理器几乎一样，只不过第三代将 `salt` 叫 `Secret Key`。

![第三代密码管理器原理](https://cdn.jsdelivr.net/gh/Optimus-Xs/Blog-Images/2022-06-21-the-evolution-of-password-managers%2Fgen3-principle.jpeg)

### 第三代的关键区别

通过网络同步时，第二代密码管理器会将生成加密密钥的参数 `salt` 一起同步，而第三代密码管理器并不会同步 `Secret Key`！

> 注意：第三代密码管理器不同步 `Secret Key`！
{: .prompt-warning }

第二代密码管理器在登录新设备时，只需输入账号密码，就可以解密云端同步下来的数据。而第三代密码管理器在登录新设备时，除账号密码外，还需要输入 `Secret Key`，才能解密云端下载的数据。虽然只是一个小改动，却极大提升了云端同步的安全性。

第三代密码管理器的主要特点：除主密码外，还增加了一个不同步的 `Secret Key`。正因为有这个 `Secret Key`，第三代密码管理器才能保证：即使云端被入侵、主密码被泄露，黑客依然无法获取用户存储的账号密码。

回顾可知，其实每一代密码管理器都比上一代增加了一个解锁条件，大幅提升安全性。

| 代数   | 解密条件                                     |
| :----- | :------------------------------------------- |
| 第一代 | 访问数据库权限                               |
| 第四代 | 访问数据库权限 <br/> 主密码                  |
| 第三代 | 访问数据库权限 <br/> 主密码 <br/> Secret Key |

### 安全问题

虽然云端没问题，但是终端依然有漏洞。对一个人来说，要想成功盗取存在第三代密码管理器中的密码，只需两步：

- 入侵用户桌面系统，获取数据文件和主密钥；
- 攻破用户的主密码

实现第一步并不难，当用户在设备上首次登入自己账号后，第三代密码管理器会把主密钥保存在本地（不会让用户每次都输入）。

传统密码管理器都是基于桌面计算机时代的技术开发的（Windows 操作系统是主要代表）。在传统的桌面操作系统上，密码管理器保存的数据文件是可以被恶意软件直接读取的，甚至恶意网站都有可能利用浏览器的安全漏洞来读取数据并发送到云端。

总结，在终端设备上，第三代密码管理器和第二代一样，离泄露所有密码都只有“**一个主密码的距离**”。

## 第四代密码管理器
### 技术架构

安全技术——**基于安全芯片**的数据保护技术，不再担心主密码泄露

过去十几年，各种密码管理器软件层出不穷，各类营销口号花样百出，但是其使用的数据保护技术在本质上却没有太大改进。因此，很多对数据安全有更高要求的用户只能选择专用硬件密码管理器产品，默默忍受着诸多不便。

让人兴奋的是，智能手机的发展为我们带来很多新的安全技术，其中之一是沙盒隔离。在 iOS 和 Android 系统上，所有 App 都可以选择使用沙盒隔离，每个 App 的私有数据都不能被其他 App 访问。即使用户不小心安装恶意 App，它也无法偷取其他 App 的私有数据（除非它能突破沙盒保护或者获取到 root 权限）。

> 当然，并非所有 App 都会使用沙盒隔离。相反，有些 App 可能会选择使用外部存储，比如 Keepass2Android。Keepass2Android 数据库保存在外部存储中，所有能访问外部存储的 App 都能读取该数据库。因此，如果你的手机不小心安装恶意 App，该 App 就能一边截获你输入的主密码，一边读取数据库文件。这样，你存储的所有密码都会泄露。

虽然沙盒技术对数据保护有一定作用，但无法防止数据因系统备份、网络同步、应用克隆等操作而泄露。真正激动人心的是，智能手机带来安全芯片的普及，这也为第四代密码管理器的诞生奠定坚实的技术基础。

现在，大多数智能手机都集成生物识别技术。为安全处理用户的生物信息，它们也都引入安全芯片。

![安卓手机的指纹识别硬件架构图](https://cdn.jsdelivr.net/gh/Optimus-Xs/Blog-Images/2022-06-21-the-evolution-of-password-managers%2Fgen4-android-fingerprint-recognitiona-architecture.png)

图中的 TEE 是独立于 CPU 和操作系统的安全芯片系统（iOS 中叫 Secure Enclave）。指纹传感器硬件线路直连安全芯片，直接将扫描的生物数据发送到安全芯片内部验证，安全芯片只告诉操作系统验证结果，保证生物数据的安全。

App 使用指纹验证的过程，大概如下：

-应用程序先调用操作系统 API，请求系统验证指纹；
-操作系统指纹管理和服务组件，请求 TEE 验证用户指纹；
-TEE 读取并且验证指纹数据；
-TEE 把验证结果告知操作系统，操作系统再告知应用程序

因此，担心 App 偷取指纹数据的用户可以放心，App 根本无法读取你的指纹数据。不过，使用人脸识别的 App 却能采集人脸数据，因为摄像头扫描的数据是 App 直接处理的（iPhone 面部 ID 验证除外）。

第四代密码管理器使用手机安全芯片保护用户数据。

安全芯片中存储的数据都是加密的，运行时的内存也是加密的，加密密钥存储在芯片内部。即使是外部操作系统，也无法访问安全芯片中的数据、无法获取加密数据的密钥。

安全芯片加密数据示意图

![安全芯片加密数据示意图](https://cdn.jsdelivr.net/gh/Optimus-Xs/Blog-Images/2022-06-21-the-evolution-of-password-managers%2Fgen4-encrypt-by-chip.png)

App 可以请求安全芯片创建密钥，并且只有创建密钥的 App 才能请求安全芯片使用这个密钥执行加密算法。不论是加密还是解密，都由安全芯片处理，App 只能得到加密/解密的结果，而得不到密钥。

回顾第二代密码管理器，既不能写死密钥，也不能把密钥和数据库一起保存，所以只能通过主密码生成密钥来加密数据。

而现在，第四代密码管理器可以使用安全芯片来安全存储密钥了。因此，就算用户不设置主密码，数据也是非常安全的，因为尽管其他 App 窃取数据库，也无法解密得到原文。

使用第四代密码管理器，只要手机解锁密码足够安全，那就完全可以不设置主密码了。

### 安全分析

第四代密码管理器的密钥存储在安全芯片内部，加密的数据只能在本机解密，离开本机将无法解密。

- 设置主密码仍然足够安全
  - 二代和第三代密码管理器，必须依赖主密码生成密钥来保护数据，否则就和第一代密码管理器一样，可以被其他程序读取用户数据。
  - 四代密码管理器，保护数据的密钥存储在安全芯片内部，即使是操作系统也不可提取，因此不设置主密码也能保护用户数据。
- 据库被盗+泄露主密码，仍然安全
  - 二代和第三代密码管理器，如果同时泄露了数据库文件和主密码（以及第三代的 SecretKey），黑客就可以使用同样算法解密数据。
  - 四代密码管理器，使用存储在安全芯片内部的密钥来保护数据，黑客无法从安全芯片中提取出密钥，无法解密数据。
- 据库被盗+暴力破解，仍然安全
  - 二代和第三代密码管理器，如果数据库文件（以及第三代的 SecretKey）泄露了，并且主密码不够强，黑客就可能通过租用大量云服务计算资源进行暴力破解。
  - 四代密码管理器，使用了存储在安全芯片内部的密钥来保护数据，即使黑客暴力破解了主密码，也无法解密数据。

当然，有利就有弊，使用安全芯片在大幅提升安全性的同时，第四代密码管理器也难以同步数据到其他设备。

由于密钥存储在安全芯片内部，无法从一个手机迁移到另一个手机，所以如果仅仅把加密后的数据同步到新手机，同样也是无法解密的。

### 攻击方案

任何技术都是可以被攻击的，第四代密码管理器也不例外，毕竟 App 不可能 100%弄清楚使用者是合法用户还是攻击者。

回顾一下，黑客要偷取前几代密码管理器中保存的密码应具备的条件：

- 第一代密码管理器，能读取数据库文件即可；
- 第二代密码管理器，需要读取数据库文件 + 偷取/破解主密码；
- 第三代密码管理器，需要读取数据库文件 + 偷取/破解主密码 + 读取主密钥 ；

第四代密码管理器，尽管读取数据库文件 + 偷取/破解主密码也无法解密。攻击者还需要：

- 控制手机（因为数据离开手机就无法解密）；
- 突破安全芯片的防护；

| 代数   | 解密条件                                                       |
| :----- | :------------------------------------------------------------- |
| 第一代 | 访问数据库权限                                                 |
| 第四代 | 访问数据库权限 <br/> 主密码                                    |
| 第三代 | 访问数据库权限 <br/> 主密码 <br/> Secret Key                   |
| 第三代 | 访问数据库权限 <br/> 主密码 <br/> 控制设备  <br/> 破解安全芯片 |


# 参考

- [密码管理器的进化史（上）](https://www.infoq.cn/article/jrr56ufm8h2jckepi5qg)
- [密码管理器的进化史（下）](https://www.infoq.cn/article/bAyVjxokYFJpl0hdOhoB)
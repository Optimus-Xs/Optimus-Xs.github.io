<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="zh-cn"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Java 集合类概览" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="Java集合框架 集合是java中存放对象的容器，存放于java.util包中。下图是java集合类的继承与实现关系：" /><meta property="og:description" content="Java集合框架 集合是java中存放对象的容器，存放于java.util包中。下图是java集合类的继承与实现关系：" /><link rel="canonical" href="https://optimus-xs.github.io/posts/java-collection-overview/" /><meta property="og:url" content="https://optimus-xs.github.io/posts/java-collection-overview/" /><meta property="og:site_name" content="Optimus-Xs’ Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-10-03T15:28:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Java 集合类概览" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="VWHcsZQRCRLxZT171OOZpP1emj_N4gMlSvgq8UReWz4" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-10-03T15:28:00+08:00","datePublished":"2020-10-03T15:28:00+08:00","description":"Java集合框架 集合是java中存放对象的容器，存放于java.util包中。下图是java集合类的继承与实现关系：","headline":"Java 集合类概览","mainEntityOfPage":{"@type":"WebPage","@id":"https://optimus-xs.github.io/posts/java-collection-overview/"},"url":"https://optimus-xs.github.io/posts/java-collection-overview/"}</script><title>Java 集合类概览 | Optimus-Xs' Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Optimus-Xs' Blog"><meta name="application-name" content="Optimus-Xs' Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/miTu.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Optimus-Xs' Blog</a></div><div class="site-subtitle font-italic">「Think Different」</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Optimus-Xs" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['Wenlong.Zuo','outlook.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Java 集合类概览</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Java 集合类概览</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/Optimus-Xs">Optimus-Xs</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1601710080" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-10-03 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="9210 字"> <em>51 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="java集合框架">Java集合框架</h1><p>集合是java中存放对象的容器，存放于java.util包中。下图是java集合类的继承与实现关系：</p><p><img data-src="https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif" alt="java集合类的继承与实现关系" data-proofer-ignore></p><h2 id="框架图说明"><span class="mr-2">框架图说明</span><a href="#框架图说明" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ol><li>所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。<li>集合接口：6个接口（短虚线表示），表示不同集合类型，是集合框架的基础。<li>抽象类：5个抽象类（长虚线表示），对集合接口的部分实现。可扩展为自定义集合类。<li>实现类：8个实现类（实线表示），对接口的具体实现。<li>Collection 接口是一组允许重复的对象。<li>Set 接口继承 Collection，集合元素不重复。<li>List 接口继承 Collection，允许重复，维护元素插入顺序。<li>Map接口是键－值对象，与Collection接口没有什么关系。<li>Set、List和Map可以看做集合的三大类：<ul><li>List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。<li>Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问（也是集合里元素不允许重复的原因）。<li>Map集合中保存Key-value对形式的元素，访问时只能根据每项元素的key来访问其value。</ul></ol><h2 id="框架图分析"><span class="mr-2">框架图分析</span><a href="#框架图分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>看上面的框架图，先抓住它的主干，即Collection和Map。</p><ol><li>Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。Collection包含了List和Set两大分支。 List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。List的实现类有LinkedList, ArrayList, Vector, Stack。 Set是一个不允许有重复元素的集合。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。<li>Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。Hashtable虽然继承于Dictionary，但它实现了Map接口。<li>接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。<li>再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。<li>最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。</ol><p>有了上面的整体框架之后，我们接下来对每个类分别进行分析。</p><h1 id="collection接口">Collection接口</h1><p>Collection接口是处理对象集合的根接口，其中定义了很多对元素进行操作的方法。Collection接口有两个主要的子接口List和Set</p><blockquote class="prompt-warning"><div><p>注意Map不是Collection的子接口，这个要牢记。</p></div></blockquote><p>Collection接口中的方法如下:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">方法名称<th style="text-align: left">说明<tbody><tr><td style="text-align: left">boolean add(E e)<td style="text-align: left">向集合中添加一个元素，E 是元素的数据类型<tr><td style="text-align: left">boolean addAll(Collection c)<td style="text-align: left">向集合中添加集合 c 中的所有元素<tr><td style="text-align: left">void clear()<td style="text-align: left">删除集合中的所有元素<tr><td style="text-align: left">boolean contains(Object o)<td style="text-align: left">判断集合中是否存在指定元素<tr><td style="text-align: left">boolean containsAll(Collection c)<td style="text-align: left">判断集合中是否包含集合 c 中的所有元素<tr><td style="text-align: left">boolean isEmpty()<td style="text-align: left">判断集合是否为空<tr><td style="text-align: left">Iterator<E>iterator()</E><td style="text-align: left">返回一个 Iterator 对象，用于遍历集合中的元素<tr><td style="text-align: left">boolean remove(Object o)<td style="text-align: left">从集合中删除一个指定元素<tr><td style="text-align: left">boolean removeAll(Collection c)<td style="text-align: left">从集合中删除所有在集合 c 中出现的元素<tr><td style="text-align: left">boolean retainAll(Collection c)<td style="text-align: left">仅仅保留集合中所有在集合 c 中出现的元素<tr><td style="text-align: left">int size()<td style="text-align: left">返回集合中元素的个数<tr><td style="text-align: left">Object[] toArray()<td style="text-align: left">返回包含此集合中所有元素的数组</table></div><h2 id="list接口"><span class="mr-2">List接口</span><a href="#list接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>List集合代表一个有序集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素。</p><p>List接口继承于Collection接口，它可以定义一个允许重复的有序集合。因为List中的元素是有序的，所以我们可以通过使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。</p><p>List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><h3 id="arraylist"><span class="mr-2">ArrayList</span><a href="#arraylist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容操作而浪费时间、效率。</p><p>size、isEmpty、get、set、iterator和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说，添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。</p><p><strong>ArrayList擅长于随机访问。同时ArrayList是非同步的</strong></p><h3 id="linkedlist"><span class="mr-2">LinkedList</span><a href="#linkedlist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。</p><p>由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。</p><p>与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">List</span> <span class="n">list</span> <span class="o">=</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">synchronizedList</span><span class="o">(</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">(...));</span>
</pre></table></code></div></div><h3 id="vector"><span class="mr-2">Vector</span><a href="#vector" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。</p><blockquote class="prompt-tip"><div><p>已被ArrayList替代</p></div></blockquote><h3 id="stack"><span class="mr-2">Stack</span><a href="#stack" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><h2 id="set接口"><span class="mr-2">Set接口</span><a href="#set接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样允许null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。Set接口有三个具体实现类，分别是散列集HashSet、链式散列集LinkedHashSet和树形集TreeSet。</p><p>Set是一种不包含重复的元素的Collection，无序，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。</p><p>需要注意的是：虽然Set中元素没有顺序，但是元素在set中的位置是由该元素的HashCode决定的，其具体位置其实是固定的。</p><blockquote class="prompt-tip"><div><p>此外需要说明一点，在set接口中的不重复是有特殊要求的。</p></div></blockquote><p>举一个例子：对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。</p><p>为了更好地理解，请看下面的例子：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span><span class="o">{</span> 
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span> 
     <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">set</span><span class="o">=</span><span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span> 
     <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span> 
     <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"world"</span><span class="o">);</span> 
     <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Hello"</span><span class="o">);</span> 
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"集合的尺寸为:"</span><span class="o">+</span><span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">());</span> 
     <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"集合中的元素为:"</span><span class="o">+</span><span class="n">set</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span> 
  <span class="o">}</span> 
<span class="o">}</span>
</pre></table></code></div></div><p>运行结果：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>集合的尺寸为:2
集合中的元素为:[world, Hello]
</pre></table></code></div></div><p>分析：由于String类中重写了hashcode和equals方法，用来比较指向的字符串对象所存储的字符串是否相等。所以这里的第二个Hello是加不进去的。</p><p>再看一个例子：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestSet</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>

        <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">books</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
        <span class="c1">//添加一个字符串对象</span>
        <span class="n">books</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"Struts2权威指南"</span><span class="o">));</span>

        <span class="c1">//再次添加一个字符串对象，</span>
        <span class="c1">//因为两个字符串对象通过equals方法比较相等，所以添加失败，返回false</span>
        <span class="kt">boolean</span> <span class="n">result</span> <span class="o">=</span> <span class="n">books</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"Struts2权威指南"</span><span class="o">));</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>

        <span class="c1">//下面输出看到集合只有一个元素</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">books</span><span class="o">);</span>    
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>运行结果：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>false
[Struts2权威指南]
</pre></table></code></div></div><p>说明：程序中，book集合两次添加的字符串对象明显不是一个对象（程序通过new关键字来创建字符串对象），当使用==运算符判断返回false，使用equals方法比较返回true，所以不能添加到Set集合中，最后只能输出一个元素</p><h3 id="hashset"><span class="mr-2">HashSet</span><a href="#hashset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>HashSet 是一个没有重复元素的集合。它是由HashMap实现的，不保证元素的顺序(这里所说的没有顺序是指：元素插入的顺序与输出的顺序不一致)，而且HashSet允许使用null 元素。HashSet是非同步的，如果多个线程同时访问一个哈希set，而其中至少一个线程修改了该set，那么它必须保持外部同步。 HashSet按Hash算法来存储集合的元素，因此具有很好的存取和查找性能。</p><p>HashSet的实现方式大致如下，通过一个HashMap存储元素，元素是存放在HashMap的Key中，而Value统一使用一个Object对象。</p><p>HashSet使用和理解中容易出现的误区:</p><ul><li>HashSet中存放null值。HashSet中是允许存入null值的，但是在HashSet中仅仅能够存入一个null值。<li>HashSet中存储元素的位置是固定的。HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的。<li>必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题</ul><h3 id="linkedhashset"><span class="mr-2">LinkedHashSet</span><a href="#linkedhashset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>LinkedHashSet继承自HashSet，其底层是基于LinkedHashMap来实现的，有序，非同步。LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素</p><h3 id="treeset"><span class="mr-2">TreeSet</span><a href="#treeset" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>reeSet是一个有序集合，其底层是基于TreeMap实现的，非线程安全。TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。当我们构造TreeSet时，若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。</p><blockquote class="prompt-warning"><div><p>注意：TreeSet集合不是通过hashcode和equals函数来比较元素的.它是通过compare或者comparaeTo函数来判断元素是否相等.compare函数通过判断两个对象的id，相同的id判断为重复元素，不会被加入到集合中。</p></div></blockquote><h2 id="queue接口"><span class="mr-2">Queue接口</span><a href="#queue接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="queue接口-1"><span class="mr-2">Queue接口</span><a href="#queue接口-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>相对于List接口来说，Queue接口中支持的方法相对就比较少了，接口代码如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span> 		<span class="c1">// 往队尾添加一个元素，失败抛出异常</span>
    <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>		<span class="c1">// 往队尾添加一个元素，失败返回false</span>
    
    <span class="no">E</span> <span class="nf">remove</span><span class="o">();</span>				<span class="c1">// 检索到队头元素并删除，返回该队头，失败抛出异常</span>
    <span class="no">E</span> <span class="nf">poll</span><span class="o">();</span>				<span class="c1">// 检索到队头元素并删除，返回该队头，失败返回null</span>
    
    <span class="no">E</span> <span class="nf">element</span><span class="o">();</span>			<span class="c1">// 检索到队头元素，并返回该队头，失败抛出异常</span>
    <span class="no">E</span> <span class="nf">peek</span><span class="o">();</span>				<span class="c1">// 检索到队头元素，并返回该队头，失败返回null</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><div><p>Queue接口不支持存放null元素。</p></div></blockquote><p>这里有个问题需要关注，原来自己用的时候也没仔细想过，为什么好像有两套功能一样的方法？即add()和offer(),remove()和poll()，element()和peek()的区别是什么？</p><p>原来，二者区别的就是在操作失败时的处理上，就好比有两套约定，在Collection接口中规定，如果add()操作失败，则抛出相应的异常; 而offer()方法则规定，如果操作失败，返回false。remove()和poll()，element()和peek()的区别类似。</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">方法<th style="text-align: left">返回值处理<th style="text-align: left">方法<th style="text-align: left">返回值处理<tbody><tr><td style="text-align: left">add()<td style="text-align: left">失败抛出异常，<br />有IllegalStateException,ClassCastException和NullPointerException三种异常。<td style="text-align: left">offer()<td style="text-align: left">失败返回false<tr><td style="text-align: left">remove()<td style="text-align: left">失败抛出NoSuchElementException异常。<td style="text-align: left">poll()<td style="text-align: left">失败返回null<tr><td style="text-align: left">element()<td style="text-align: left">失败抛出NoSuchElementException异常。<td style="text-align: left">peek()<td style="text-align: left">失败返回null</table></div><h3 id="deque接口"><span class="mr-2">Deque接口</span><a href="#deque接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>说完Queue接口，很自然地就会涉及到Deque接口。Deque，即Double End Queue，双端队列，顾名思义，就是可以在队头和队尾进行插入或删除操作，我们看下接口的设计，这里我们也只列举一部分：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Deque</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Queue</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>
    <span class="kt">void</span> <span class="nf">addLast</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="nf">offerFirst</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="nf">offerLast</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>
    
    <span class="no">E</span> <span class="nf">removeFirst</span><span class="o">();</span>
    <span class="no">E</span> <span class="nf">removeLast</span><span class="o">();</span>
    <span class="no">E</span> <span class="nf">pollFirst</span><span class="o">();</span>
    <span class="no">E</span> <span class="nf">pollLast</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>Okay，和我们的猜想一模一样，至于为什么也有两套一样的方法嘛，和上面在Queue中的解释完完全全一样。</p><h3 id="arraydeque实现"><span class="mr-2">ArrayDeque实现</span><a href="#arraydeque实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>ArrayDeque类是实现了Deque接口的，常见的使用方法如下</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nc">Deque</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">dq</span><span class="o">=</span><span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>
<span class="n">dq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"jack"</span><span class="o">);</span>
<span class="n">dq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"andy"</span><span class="o">);</span>
<span class="n">dq</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"rose"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dq</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>  <span class="c1">// 输出 [jack, andy, rose]</span>

<span class="n">dq</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">dq</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>  <span class="c1">// 输出 [jack, andy]</span>
</pre></table></code></div></div><h3 id="linkedlist实现queue"><span class="mr-2">LinkedList实现Queue</span><a href="#linkedlist实现queue" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>LinkedList即可以作为朴素队列Queue接口的实现类来使用，也可以作为双端队列Deque接口的实现类来使用</p><p>LinkedList作为朴素队列来使用的代码如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">=</span><span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
<span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"jack"</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"andy"</span><span class="o">);</span>
<span class="n">q</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"rose"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>  <span class="c1">// 输出 [jack, andy, rose]</span>

<span class="n">q</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>  <span class="c1">// 输出 [andy, rose]</span>
</pre></table></code></div></div><h1 id="map接口">Map接口</h1><p>Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。</p><h2 id="hashmap"><span class="mr-2">HashMap</span><a href="#hashmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组（Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构</p><h2 id="linkedhashmap"><span class="mr-2">LinkedHashMap</span><a href="#linkedhashmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>LinkedHashMap是HashMap的一个子类，它保留插入的顺序，如果需要输出的顺序和输入时的相同，那么就选用LinkedHashMap</p><p>LinkedHashMap是Map接口的哈希表和链接列表实现，具有可预知的迭代顺序。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。</p><p>根据链表中元素的顺序可以分为：按插入顺序的链表，和按访问顺序(调用get方法)的链表。默认是按插入顺序排序，如果指定按访问顺序排序，那么调用get方法后，会将这次访问的元素移至链表尾部，不断访问可以形成按访问顺序排序的链表。</p><blockquote class="prompt-warning"><div><p>注意，此实现不是同步的。如果多个线程同时访问链接的哈希映射，而其中至少一个线程从结构上修改了该映射，则它必须保持外部同步。由于LinkedHashMap需要维护元素的插入顺序，因此性能略低于HashMap的性能，但在迭代访问Map里的全部元素时将有很好的性能，因为它以链表来维护内部顺序。</p></div></blockquote><h2 id="treemap"><span class="mr-2">TreeMap</span><a href="#treemap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>TreeMap 是一个有序的key-value集合，非同步，基于红黑树（Red-Black tree）实现，每一个key-value节点作为红黑树的一个节点。TreeMap存储时会进行排序的，会根据key来对key-value键值对进行排序，其中排序方式也是分为两种，一种是自然排序，一种是定制排序，具体取决于使用的构造方法。</p><p>自然排序：TreeMap中所有的key必须实现Comparable接口，并且所有的key都应该是同一个类的对象，否则会报ClassCastException异常。</p><p>定制排序：定义TreeMap时，创建一个comparator对象，该对象对所有的treeMap中所有的key值进行排序，采用定制排序的时候不需要TreeMap中所有的key必须实现Comparable接口。</p><p>TreeMap判断两个元素相等的标准：两个key通过compareTo()方法返回0，则认为这两个key相等。</p><p>如果使用自定义的类来作为TreeMap中的key值，且想让TreeMap能够良好的工作，则必须重写自定义类中的equals()方法，TreeMap中判断相等的标准是：两个key通过equals()方法返回为true，并且通过compareTo()方法比较应该返回为0。</p><h1 id="iterator-与-listiterator详解">Iterator 与 ListIterator详解</h1><h2 id="iterator"><span class="mr-2">Iterator</span><a href="#iterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Iterator的定义如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{}</span>

</pre></table></code></div></div><p>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。</p><p>Iterator提供的API接口如下：</p><p>boolean hasNext()：判断集合里是否存在下一个元素。如果有，hasNext()方法返回 true。 Object next()：返回集合里下一个元素。 void remove()：删除集合里上一次next方法返回的元素。</p><p>使用示例</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">IteratorExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
        <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"aaa"</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"bbb"</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"ccc"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before iterate : "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span>
        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">t</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"bbb"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">it</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After iterate : "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>输出结果如下：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>Before iterate : [aaa, bbb, ccc]
After iterate : [aaa, ccc]
</pre></table></code></div></div><blockquote class="prompt-warning"><div><p>注意：</p><ul><li>Iterator只能单向移动。<li>Iterator.remove()是唯一安全的方式来在迭代过程中修改集合；如果在迭代过程中以任何其它的方式修改了基本集合将会产生未知的行为。而且每调用一次next()方法，remove()方法只能被调用一次，如果违反这个规则将抛出一个异常</ul></div></blockquote><h2 id="listiterator"><span class="mr-2">ListIterator</span><a href="#listiterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>ListIterator是一个功能更加强大的迭代器, 它继承于Iterator接口，只能用于各种List类型的访问。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator, 还可以调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator。</p><p>ListIterator接口定义如下:</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ListIterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Iterator</span><span class="o">&lt;</span><span class="no">E</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kt">boolean</span> <span class="nf">hasNext</span><span class="o">();</span>

    <span class="no">E</span> <span class="nf">next</span><span class="o">();</span>

    <span class="kt">boolean</span> <span class="nf">hasPrevious</span><span class="o">();</span>

    <span class="no">E</span> <span class="nf">previous</span><span class="o">();</span>

    <span class="kt">int</span> <span class="nf">nextIndex</span><span class="o">();</span>

    <span class="kt">int</span> <span class="nf">previousIndex</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">remove</span><span class="o">();</span>

    <span class="kt">void</span> <span class="nf">set</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>

    <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>由以上定义我们可以推出ListIterator可以:</p><ul><li>双向移动（向前/向后遍历）.<li>产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引.<li>可以使用set()方法替换它访问过的最后一个元素.<li>可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之后插入一个元素.</ul><p>使用示例：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListIteratorExample</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>
        <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"aaa"</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"bbb"</span><span class="o">);</span>
        <span class="n">a</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"ccc"</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Before iterate : "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span>
        <span class="nc">ListIterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">it</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">listIterator</span><span class="o">();</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">previousIndex</span><span class="o">()</span> <span class="o">+</span> <span class="s">", "</span> <span class="o">+</span> <span class="n">it</span><span class="o">.</span><span class="na">nextIndex</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasPrevious</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">previous</span><span class="o">()</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">();</span>
        <span class="n">it</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">listIterator</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">t</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">t</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="s">"ccc"</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">t</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">it</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="s">"nnn"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">it</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"kkk"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"After iterate : "</span> <span class="o">+</span> <span class="n">a</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>输出结果如下：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>Before iterate : [aaa, bbb, ccc]
aaa, 0, 1
bbb, 1, 2
ccc, 2, 3
ccc bbb aaa 
bbb
ccc
After iterate : [aaa, bbb, kkk, nnn]
</pre></table></code></div></div><h1 id="常见相似集合类差异点">常见相似集合类差异点</h1><h2 id="arraylist和linkedlist"><span class="mr-2">ArrayList和LinkedList</span><a href="#arraylist和linkedlist" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<li>对于随机访问get和set，ArrayList绝对优于LinkedList，因为LinkedList要移动指针。<li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</ul><p>这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。</p><h2 id="hashtable与hashmap"><span class="mr-2">HashTable与HashMap</span><a href="#hashtable与hashmap" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>相同点：</p><p>都实现了Map、Cloneable、java.io.Serializable接口。 都是存储”键值对(key-value)”的散列表，而且都是采用拉链法实现的。 不同点：</p><ol><li><p>历史原因：HashTable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。</p><li><p>同步性：HashTable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。</p><li><p>对null值的处理：HashMap的key、value都可为null，HashTable的key、value都不可为null 。</p><li>基类不同：HashMap继承于AbstractMap，而Hashtable继承于Dictionary。<ul><li>Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代M器)去遍历。然而由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。<li>AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。</ul><li>支持的遍历种类不同：HashMap只支持Iterator(迭代器)遍历。而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。</ol><h2 id="hashmaphashtablelinkedhashmap和treemap比较"><span class="mr-2">HashMap、Hashtable、LinkedHashMap和TreeMap比较</span><a href="#hashmaphashtablelinkedhashmap和treemap比较" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Hashmap 是一个最常用的Map，它根据键的HashCode 值存储数据，根据键可以直接获取它的值，具有很快的访问速度。遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null；允许多条记录的值为Null；HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap；可能会导致数据的不一致。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p><p>Hashtable 与 HashMap类似，不同的是：它不允许记录的键或者值为空；它支持线程的同步，即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在写入时会比较慢。</p><p>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p><p>如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。LinkedHashMap实现与HashMap的不同之处在于，后者维护着一个运行于所有条目的双重链表。此链接列表定义了迭代顺序，该迭代顺序可以是插入顺序或者是访问顺序。对于LinkedHashMap而言，它继承与HashMap、底层使用哈希表与双向链表来保存所有元素。其基本操作与父类HashMap相似，它通过重写父类相关的方法，来实现自己的链接列表特性。</p><p>TreeMap实现SortMap接口，内部实现是红黑树。能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。TreeMap不允许key的值为null。非同步的。</p><p>一般情况下，我们用的最多的是HashMap，HashMap里面存入的键值对在取出的时候是随机的，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。</p><p>TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。</p><p>LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同，那么用LinkedHashMap可以实现，它还可以按读取顺序来排列，像连接池中可以应用。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MapTest</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">//HashMap</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">hashMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">();</span>
        <span class="n">hashMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"4"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">);</span>
        <span class="n">hashMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"3"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
        <span class="n">hashMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"2"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
        <span class="n">hashMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">);</span>

        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">iteratorHashMap</span> <span class="o">=</span> <span class="n">hashMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HashMap--&gt;"</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">iteratorHashMap</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>

            <span class="nc">Object</span> <span class="n">key1</span> <span class="o">=</span> <span class="n">iteratorHashMap</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key1</span> <span class="o">+</span> <span class="s">"--"</span> <span class="o">+</span> <span class="n">hashMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key1</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">//LinkedHashMap</span>
        <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">linkedHashMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">();</span>
        <span class="n">linkedHashMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"4"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">);</span>
        <span class="n">linkedHashMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"3"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
        <span class="n">linkedHashMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"2"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
        <span class="n">linkedHashMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">);</span>

        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">iteratorLinkedHashMap</span> <span class="o">=</span> <span class="n">linkedHashMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LinkedHashMap--&gt;"</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">iteratorLinkedHashMap</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>

            <span class="nc">Object</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">iteratorLinkedHashMap</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key2</span> <span class="o">+</span> <span class="s">"--"</span> <span class="o">+</span> <span class="n">linkedHashMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key2</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="c1">//TreeMap</span>
        <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">treeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">();</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"4"</span><span class="o">,</span> <span class="s">"d"</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"3"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"2"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">);</span>
        <span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"1"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">);</span>

        <span class="nc">Iterator</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">iteratorTreeMap</span> <span class="o">=</span> <span class="n">treeMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">().</span><span class="na">iterator</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"TreeMap--&gt;"</span><span class="o">);</span>

        <span class="k">while</span> <span class="o">(</span><span class="n">iteratorTreeMap</span><span class="o">.</span><span class="na">hasNext</span><span class="o">()){</span>

            <span class="nc">Object</span> <span class="n">key3</span> <span class="o">=</span> <span class="n">iteratorTreeMap</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">key3</span> <span class="o">+</span> <span class="s">"--"</span> <span class="o">+</span> <span class="n">treeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key3</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>输出结果：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre>HashMap--&gt;
3--c
2--b
1--a
4--d
LinkedHashMap--&gt;
4--d
3--c
2--b
1--a
TreeMap--&gt;
1--a
2--b
3--c
4--d
</pre></table></code></div></div><h2 id="hashsetlinkedhashsettreeset比较"><span class="mr-2">HashSet、LinkedHashSet、TreeSet比较</span><a href="#hashsetlinkedhashsettreeset比较" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="set接口-1"><span class="mr-2">Set接口</span><a href="#set接口-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Set不允许包含相同的元素，如果试图把两个相同元素加入同一个集合中，add方法返回false。</p><p>Set判断两个对象相同不是使用==运算符，而是根据equals方法。也就是说，只要两个对象用equals方法比较返回true，Set就不会接受这两个对象。</p><h4 id="hashset-1"><span class="mr-2">HashSet</span><a href="#hashset-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>HashSet有以下特点：</p><ul><li>不能保证元素的排列顺序，顺序有可能发生变化。<li>不是同步的。<li>集合元素可以是null，但只能放入一个null。</ul><p>当向HashSet结合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据 hashCode值来决定该对象在HashSet中存储位置。简单的说，HashSet集合判断两个元素相等的标准是两个对象通过equals方法比较相等，并且两个对象的hashCode()方法返回值也相等。</p><blockquote class="prompt-tip"><div><p>注意，如果要把一个对象放入HashSet中，重写该对象对应类的equals方法，也应该重写其hashCode()方法。其规则是如果两个对象通过equals方法比较返回true时，其hashCode也应该相同。另外，对象中用作equals比较标准的属性，都应该用来计算 hashCode的值。</p></div></blockquote><h3 id="linkedhashset-1"><span class="mr-2">LinkedHashSet</span><a href="#linkedhashset-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>LinkedHashSet集合同样是根据元素的hashCode值来决定元素的存储位置，但是它同时使用链表维护元素的次序。这样使得元素看起来像是以插入顺序保存的，也就是说，当遍历该集合时候，LinkedHashSet将会以元素的添加顺序访问集合的元素。</p><p><strong>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet。</strong></p><h3 id="treeset类"><span class="mr-2">TreeSet类</span><a href="#treeset类" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>TreeSet是SortedSet接口的唯一实现类，TreeSet可以确保集合元素处于排序状态。TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。向TreeSet中加入的应该是同一个类的对象。</p><p>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0。</p><h3 id="自然排序"><span class="mr-2">自然排序</span><a href="#自然排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>自然排序使用要排序元素的CompareTo（Object obj）方法来比较元素之间大小关系，然后将元素按照升序排列。</p><p>Java提供了一个Comparable接口，该接口里定义了一个compareTo(Object obj)方法，该方法返回一个整数值，实现了该接口的对象就可以比较大小。obj1.compareTo(obj2)方法如果返回0，则说明被比较的两个对象相等，如果返回一个正数，则表明obj1大于obj2，如果是负数，则表明obj1小于obj2。如果我们将两个对象的equals方法总是返回true，则这两个对象的compareTo方法返回应该返回0。</p><h3 id="定制排序"><span class="mr-2">定制排序</span><a href="#定制排序" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>自然排序是根据集合元素的大小，以升序排列，如果要定制排序，应该使用Comparator接口，实现 int compare(T o1,T o2)方法。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">com.test</span><span class="o">;</span>  

<span class="kn">import</span> <span class="nn">java.util.HashSet</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.util.LinkedHashSet</span><span class="o">;</span>  
<span class="kn">import</span> <span class="nn">java.util.TreeSet</span><span class="o">;</span>  

<span class="cm">/**  
 * @description 几个set的比较  
 *    HashSet：哈希表是通过使用称为散列法的机制来存储信息的，元素并没有以某种特定顺序来存放；  
 *    LinkedHashSet：以元素插入的顺序来维护集合的链接表，允许以插入的顺序在集合中迭代；  
 *    TreeSet：提供一个使用树结构存储Set接口的实现，对象以升序顺序存储，访问和遍历的时间很快。    
 */</span>  
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SetDemo</span> <span class="o">{</span>  

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>  

        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">hs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>  
        <span class="n">hs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"B"</span><span class="o">);</span>  
        <span class="n">hs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"A"</span><span class="o">);</span>  
        <span class="n">hs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"D"</span><span class="o">);</span>  
        <span class="n">hs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"E"</span><span class="o">);</span>  
        <span class="n">hs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"C"</span><span class="o">);</span>  
        <span class="n">hs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"F"</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"HashSet 顺序:\n"</span><span class="o">+</span><span class="n">hs</span><span class="o">);</span>  

        <span class="nc">LinkedHashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">lhs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>  
        <span class="n">lhs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"B"</span><span class="o">);</span>  
        <span class="n">lhs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"A"</span><span class="o">);</span>  
        <span class="n">lhs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"D"</span><span class="o">);</span>  
        <span class="n">lhs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"E"</span><span class="o">);</span>  
        <span class="n">lhs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"C"</span><span class="o">);</span>  
        <span class="n">lhs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"F"</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"LinkedHashSet 顺序:\n"</span><span class="o">+</span><span class="n">lhs</span><span class="o">);</span>  

        <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">ts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;();</span>  
        <span class="n">ts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"B"</span><span class="o">);</span>  
        <span class="n">ts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"A"</span><span class="o">);</span>  
        <span class="n">ts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"D"</span><span class="o">);</span>  
        <span class="n">ts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"E"</span><span class="o">);</span>  
        <span class="n">ts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"C"</span><span class="o">);</span>  
        <span class="n">ts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"F"</span><span class="o">);</span>  
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"TreeSet 顺序:\n"</span><span class="o">+</span><span class="n">ts</span><span class="o">);</span>  
    <span class="o">}</span>  
<span class="o">}</span>
</pre></table></code></div></div><p>输出结果：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>HashSet 顺序:[D, E, F, A, B, C]
LinkedHashSet 顺序:[B, A, D, E, C, F]
TreeSet 顺序:[A, B, C, D, E, F]
</pre></table></code></div></div><h2 id="iterator和listiterator区别"><span class="mr-2">Iterator和ListIterator区别</span><a href="#iterator和listiterator区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>我们在使用List，Set的时候，为了实现对其数据的遍历，我们经常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍历的过程，只需要每次取出一个你想要的数据进行处理就可以了。但是在使用的时候也是有不同的。</p><p>List和Set都有iterator()来取得其迭代器。对List来说，你也可以通过listIterator()取得其迭代器，两种迭代器在有些时候是不能通用的，Iterator和ListIterator主要区别在以下方面：</p><ul><li>ListIterator有add()方法，可以向List中添加对象，而Iterator不能<li>ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。<li>ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。<li>都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。</ul><p>因为ListIterator的这些功能，可以实现对LinkedList等List数据结构的操作。其实，数组对象也可以用迭代器来实现。</p><h2 id="collection-和-collections区别"><span class="mr-2">Collection 和 Collections区别</span><a href="#collection-和-collections区别" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre> Collection   
├List   
│├LinkedList   
│├ArrayList   
│└Vector   
│　└Stack   
└Set 
</pre></table></code></div></div><p>java.util.Collections 是一个包装类（工具类/帮助类）。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，用于对集合中元素进行排序、搜索以及线程安全等各种操作，服务于Java的Collection框架。</p><p>代码示例：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestCollections</span> <span class="o">{</span> 

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span> <span class="n">args</span><span class="o">[])</span> <span class="o">{</span> 
        <span class="c1">//注意List是实现Collection接口的 </span>
        <span class="nc">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">();</span> 
        <span class="kt">double</span> <span class="n">array</span><span class="o">[]</span> <span class="o">=</span> <span class="o">{</span> <span class="mi">112</span><span class="o">,</span> <span class="mi">111</span><span class="o">,</span> <span class="mi">23</span><span class="o">,</span> <span class="mi">456</span><span class="o">,</span> <span class="mi">231</span> <span class="o">};</span> 
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> 
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Double</span><span class="o">(</span><span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span> 
        <span class="o">}</span> 
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">);</span> 
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span> 
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span> 
        <span class="o">}</span> 
        <span class="c1">// 结果：23.0 111.0 112.0 231.0 456.0 </span>
    <span class="o">}</span> 
<span class="o">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/software-development/'>Software Development</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://t.me/share/url?url=https://optimus-xs.github.io/posts/java-collection-overview/&amp;text=Java 集合类概览 - Optimus-Xs&#39; Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://optimus-xs.github.io/posts/java-collection-overview/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/how-to-write-a-dockerfile-elegantly/">如何优雅的编写Dockerfile</a><li><a href="/posts/java-file-io-usage/">Java 文件 IO 使用方法</a><li><a href="/posts/jvm-gc-mechanism/">JVM 的垃圾回收机制</a><li><a href="/posts/docker-engine-installation-on-ubuntu/">在 Ubuntu 上安装 Dockers Engine 流程</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/devdairy/">DevDairy</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a> <a class="post-tag" href="/tags/geekdairy/">GeekDairy</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/why-autowired-not-recommended/"><div class="card-body"> <em class="timeago small" data-ts="1602220140" > 2020-10-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>为什么使用 @Autowired 提示不推荐</h3><div class="text-muted small"><p> @Autowired注解相信每个Spring开发者都不陌生了！ 但是当我们使用IDEA写代码的时候，经常会发现@Autowired注解下面是有小黄线的，我们把小鼠标悬停在上面，可以看到这个如下图所示的警告信息： 那么为什么IDEA会给出Field injection is not recommended这样的警告呢？ 下面带着这样的问题，一起来全面的了解下Spring中的三种注入方...</p></div></div></a></div><div class="card"> <a href="/posts/java-generics-usage/"><div class="card-body"> <em class="timeago small" data-ts="1602660480" > 2020-10-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java 泛型使用方法</h3><div class="text-muted small"><p> 概述 泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 什么是泛型？为什么要使用泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（...</p></div></div></a></div><div class="card"> <a href="/posts/java-reflection-usage/"><div class="card-body"> <em class="timeago small" data-ts="1603438080" > 2020-10-23 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java 反射使用方法</h3><div class="text-muted small"><p> 反射基础 什么是反射 反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。 反射之中包含了一个「反」字，所以想要解释反射就必须先从「正」开始解释。 一般情况下，我们使用某个类时必定知道它是什么类，是用来做什么的。于是我们直接对这个类进行实例化，之后使用这个类对象进行操作。 1 2 Apple apple ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/init-test/" class="btn btn-outline-primary" prompt="上一篇"><p>Init Test</p></a> <a href="/posts/why-autowired-not-recommended/" class="btn btn-outline-primary" prompt="下一篇"><p>为什么使用 @Autowired 提示不推荐</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Optimus-Xs">Optimus-Xs</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/devdairy/">DevDairy</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a> <a class="post-tag" href="/tags/geekdairy/">GeekDairy</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh-cn.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>

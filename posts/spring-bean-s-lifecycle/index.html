<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="zh-cn"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Spring Bean 的生命周期" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="生命周期的概要流程 Spring Bean 的整个生命周期 Google Spring Bean 的生命周期，大多以下图给出的流程作为答案" /><meta property="og:description" content="生命周期的概要流程 Spring Bean 的整个生命周期 Google Spring Bean 的生命周期，大多以下图给出的流程作为答案" /><link rel="canonical" href="https://optimus-xs.github.io/posts/spring-bean-s-lifecycle/" /><meta property="og:url" content="https://optimus-xs.github.io/posts/spring-bean-s-lifecycle/" /><meta property="og:site_name" content="Optimus-Xs’ Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-03T13:34:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Spring Bean 的生命周期" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="VWHcsZQRCRLxZT171OOZpP1emj_N4gMlSvgq8UReWz4" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-01-03T13:34:00+08:00","datePublished":"2022-01-03T13:34:00+08:00","description":"生命周期的概要流程 Spring Bean 的整个生命周期 Google Spring Bean 的生命周期，大多以下图给出的流程作为答案","headline":"Spring Bean 的生命周期","mainEntityOfPage":{"@type":"WebPage","@id":"https://optimus-xs.github.io/posts/spring-bean-s-lifecycle/"},"url":"https://optimus-xs.github.io/posts/spring-bean-s-lifecycle/"}</script><title>Spring Bean 的生命周期 | Optimus-Xs' Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Optimus-Xs' Blog"><meta name="application-name" content="Optimus-Xs' Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/miTu.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Optimus-Xs' Blog</a></div><div class="site-subtitle font-italic">「Think Different」</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Optimus-Xs" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['Wenlong.Zuo','outlook.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Spring Bean 的生命周期</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Spring Bean 的生命周期</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/Optimus-Xs">Optimus-Xs</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1641188040" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-01-03 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4047 字"> <em>22 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="生命周期的概要流程">生命周期的概要流程</h1><h2 id="spring-bean-的整个生命周期"><span class="mr-2">Spring Bean 的整个生命周期</span><a href="#spring-bean-的整个生命周期" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Google Spring Bean 的生命周期，大多以下图给出的流程作为答案</p><p><img data-src="https://i.ibb.co/vzXxK62/Spring.png" alt="" data-proofer-ignore></p><p>但是当我第一次看到这个图时，人麻了，“Aware，BeanPostProcessor……这些都是什么啊？而且这么多步骤，太多了，该怎么记啊？”。</p><p>其实要记忆该过程，还是需要我们先去理解，本文将从以下两方面去帮助理解 Bean 的生命周期</p><ul><li>生命周期的概要流程：对 Bean 的生命周期进行概括，并且结合代码来理解；<li>扩展点的作用：详细介绍 Bean 生命周期中所涉及到的扩展点的作用。</ul><h2 id="只有四个"><span class="mr-2">只有四个！</span><a href="#只有四个" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>是的，Spring Bean的生命周期只有这四个阶段。把这四个阶段和每个阶段对应的扩展点糅合在一起虽然没有问题，但是这样非常凌乱，难以记忆。要彻底搞清楚Spring的生命周期，首先要把这四个阶段牢牢记住。实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段</p><ul><li>实例化 Instantiation<li>属性赋值 Populate<li>初始化 Initialization<li>销毁 Destruction</ul><p><img data-src="https://i.ibb.co/qW5Jkx8/Spring.png" alt="" data-proofer-ignore></p><ol><li>实例化：第 1 步，实例化一个 bean 对象；<li>属性赋值：第 2 步，为 bean 设置相关属性和依赖；<li>初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；<li>销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。</ol><p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p><p>主要逻辑都在doCreate()方法中，逻辑很清晰，就是顺序调用以下三个方法，这三个方法与三个生命周期阶段一一对应，非常重要，在后续扩展接口分析中也会涉及。</p><ul><li><code class="language-plaintext highlighter-rouge">createBeanInstance()</code> -&gt; 实例化<li><code class="language-plaintext highlighter-rouge">populateBean()</code> -&gt; 属性赋值<li><code class="language-plaintext highlighter-rouge">initializeBean()</code> -&gt; 初始化</ul><p>下面我们结合代码来直观的看下，在 doCreateBean() 方法中能看到依次执行了这 4 个阶段：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// AbstractAutowireCapableBeanFactory.java</span>
<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">doCreateBean</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="kd">final</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">BeanCreationException</span> <span class="o">{</span>

    <span class="c1">// 1. 实例化</span>
    <span class="nc">BeanWrapper</span> <span class="n">instanceWrapper</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">instanceWrapper</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">instanceWrapper</span> <span class="o">=</span> <span class="n">createBeanInstance</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="nc">Object</span> <span class="n">exposedObject</span> <span class="o">=</span> <span class="n">bean</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="c1">// 2. 属性赋值</span>
        <span class="n">populateBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbd</span><span class="o">,</span> <span class="n">instanceWrapper</span><span class="o">);</span>
        <span class="c1">// 3. 初始化</span>
        <span class="n">exposedObject</span> <span class="o">=</span> <span class="n">initializeBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">exposedObject</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 4. 销毁-注册回调接口</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">registerDisposableBeanIfNecessary</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">bean</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">exposedObject</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>由于初始化包含了第 3~7步，较复杂，所以我们进到 initializeBean() 方法里具体看下其过程（注释的序号对应图中序号）：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c1">// AbstractAutowireCapableBeanFactory.java</span>
<span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">initializeBean</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 3. 检查 Aware 相关接口并设置相关依赖</span>
    <span class="k">if</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">((</span><span class="nc">PrivilegedAction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">invokeAwareMethods</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">},</span> <span class="n">getAccessControlContext</span><span class="o">());</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="n">invokeAwareMethods</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 4. BeanPostProcessor 前置处理</span>
    <span class="nc">Object</span> <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">bean</span><span class="o">;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSynthetic</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">applyBeanPostProcessorsBeforeInitialization</span><span class="o">(</span><span class="n">wrappedBean</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 5. 若实现 InitializingBean 接口，调用 afterPropertiesSet() 方法</span>
    <span class="c1">// 6. 若配置自定义的 init-method方法，则执行</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">invokeInitMethods</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">wrappedBean</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">catch</span> <span class="o">(</span><span class="nc">Throwable</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">BeanCreationException</span><span class="o">(</span>
            <span class="o">(</span><span class="n">mbd</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">mbd</span><span class="o">.</span><span class="na">getResourceDescription</span><span class="o">()</span> <span class="o">:</span> <span class="kc">null</span><span class="o">),</span>
            <span class="n">beanName</span><span class="o">,</span> <span class="s">"Invocation of init method failed"</span><span class="o">,</span> <span class="n">ex</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="c1">// 7. BeanPostProceesor 后置处理</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">mbd</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSynthetic</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">applyBeanPostProcessorsAfterInitialization</span><span class="o">(</span><span class="n">wrappedBean</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">wrappedBean</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在 invokInitMethods() 方法中会检查 InitializingBean 接口和 init-method 方法，销毁的过程也与其类似：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// DisposableBeanAdapter.java</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 9. 若实现 DisposableBean 接口，则执行 destory()方法</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">invokeDisposableBean</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">getSecurityManager</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">AccessController</span><span class="o">.</span><span class="na">doPrivileged</span><span class="o">((</span><span class="nc">PrivilegedExceptionAction</span><span class="o">&lt;</span><span class="nc">Object</span><span class="o">&gt;)</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="o">((</span><span class="nc">DisposableBean</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">bean</span><span class="o">).</span><span class="na">destroy</span><span class="o">();</span>
                    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
                <span class="o">},</span> <span class="k">this</span><span class="o">.</span><span class="na">acc</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="o">((</span><span class="nc">DisposableBean</span><span class="o">)</span> <span class="k">this</span><span class="o">.</span><span class="na">bean</span><span class="o">).</span><span class="na">destroy</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
	<span class="c1">// 10. 若配置自定义的 detory-method 方法，则执行</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">destroyMethod</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">invokeCustomDestroyMethod</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">destroyMethod</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">destroyMethodName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Method</span> <span class="n">methodToInvoke</span> <span class="o">=</span> <span class="n">determineDestroyMethod</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">destroyMethodName</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">methodToInvoke</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">invokeCustomDestroyMethod</span><span class="o">(</span><span class="nc">ClassUtils</span><span class="o">.</span><span class="na">getInterfaceMethodIfPossible</span><span class="o">(</span><span class="n">methodToInvoke</span><span class="o">));</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>从 Spring 的源码我们可以直观的看到其执行过程，而我们记忆其过程便可以从这 4 个阶段出发，实例化、属性赋值、初始化、销毁。其中细节较多的便是初始化，涉及了 Aware、BeanPostProcessor、InitializingBean、init-method 的概念。这些都是 Spring 提供的扩展点，其具体作用将在下一节讲述。</p><h1 id="常见扩展点极其作用">常见扩展点极其作用</h1><h2 id="第一大类影响多个bean的接口"><span class="mr-2">第一大类：影响多个Bean的接口</span><a href="#第一大类影响多个bean的接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>实现了这些接口的Bean会切入到多个Bean的生命周期中。正因为如此，这些接口的功能非常强大，Spring内部扩展也经常使用这些接口，例如自动注入以及AOP的实现都和他们有关。</p><ul><li>BeanPostProcessor<li>InstantiationAwareBeanPostProcessor</ul><p>这两兄弟可能是Spring扩展中最重要的两个接口！InstantiationAwareBeanPostProcessor作用于实例化阶段的前后，BeanPostProcessor作用于初始化阶段的前后。正好和第一、第三个生命周期阶段对应。通过图能更好理解：</p><p><img data-src="https://i.ibb.co/TMQ0ZxM/4558491-dc3eebbd1d6c65f4.webp" alt="" data-proofer-ignore></p><p>InstantiationAwareBeanPostProcessor实际上继承了BeanPostProcessor接口，严格意义上来看他们不是两兄弟，而是两父子。但是从生命周期角度我们重点关注其特有的对实例化阶段的影响，图中省略了从BeanPostProcessor继承的方法。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">InstantiationAwareBeanPostProcessor</span> <span class="kd">extends</span> <span class="nc">BeanPostProcessor</span>
</pre></table></code></div></div><h3 id="instantiationawarebeanpostprocessor分析"><span class="mr-2">InstantiationAwareBeanPostProcessor分析：</span><a href="#instantiationawarebeanpostprocessor分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>postProcessBeforeInstantiation调用点，忽略无关代码：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">createBean</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">Object</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span>
            <span class="kd">throws</span> <span class="nc">BeanCreationException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span>
            <span class="c1">// postProcessBeforeInstantiation方法调用点，这里就不跟进了，</span>
            <span class="c1">// 有兴趣的同学可以自己看下，就是for循环调用所有的InstantiationAwareBeanPostProcessor</span>
            <span class="nc">Object</span> <span class="n">bean</span> <span class="o">=</span> <span class="n">resolveBeforeInstantiation</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbdToUse</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">bean</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="k">try</span> <span class="o">{</span>   
            <span class="c1">// 上文提到的doCreateBean方法，可以看到</span>
            <span class="c1">// postProcessBeforeInstantiation方法在创建Bean之前调用</span>
            <span class="nc">Object</span> <span class="n">beanInstance</span> <span class="o">=</span> <span class="n">doCreateBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">mbdToUse</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">logger</span><span class="o">.</span><span class="na">isTraceEnabled</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">logger</span><span class="o">.</span><span class="na">trace</span><span class="o">(</span><span class="s">"Finished creating instance of bean '"</span> <span class="o">+</span> <span class="n">beanName</span> <span class="o">+</span> <span class="s">"'"</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">beanInstance</span><span class="o">;</span>
        <span class="o">}</span>
        
    <span class="o">}</span>
</pre></table></code></div></div><p>可以看到，postProcessBeforeInstantiation在doCreateBean之前调用，也就是在bean实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的Bean作为代理，这也是Aop等功能实现的关键点。</p><p>postProcessAfterInstantiation调用点，忽略无关代码：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">protected</span> <span class="kt">void</span> <span class="nf">populateBean</span><span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">BeanWrapper</span> <span class="n">bw</span><span class="o">)</span> <span class="o">{</span>

   <span class="c1">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span>
   <span class="c1">// state of the bean before properties are set. This can be used, for example,</span>
   <span class="c1">// to support styles of field injection.</span>
   <span class="kt">boolean</span> <span class="n">continueWithPropertyPopulation</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="c1">// InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation()</span>
    <span class="c1">// 方法作为属性赋值的前置检查条件，在属性赋值之前执行，能够影响是否进行属性赋值！</span>
   <span class="k">if</span> <span class="o">(!</span><span class="n">mbd</span><span class="o">.</span><span class="na">isSynthetic</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">hasInstantiationAwareBeanPostProcessors</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">for</span> <span class="o">(</span><span class="nc">BeanPostProcessor</span> <span class="n">bp</span> <span class="o">:</span> <span class="n">getBeanPostProcessors</span><span class="o">())</span> <span class="o">{</span>
         <span class="k">if</span> <span class="o">(</span><span class="n">bp</span> <span class="k">instanceof</span> <span class="nc">InstantiationAwareBeanPostProcessor</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">InstantiationAwareBeanPostProcessor</span> <span class="n">ibp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">InstantiationAwareBeanPostProcessor</span><span class="o">)</span> <span class="n">bp</span><span class="o">;</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">ibp</span><span class="o">.</span><span class="na">postProcessAfterInstantiation</span><span class="o">(</span><span class="n">bw</span><span class="o">.</span><span class="na">getWrappedInstance</span><span class="o">(),</span> <span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
               <span class="n">continueWithPropertyPopulation</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
               <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
         <span class="o">}</span>
      <span class="o">}</span>
   <span class="o">}</span>
   <span class="c1">// 忽略后续的属性赋值操作代码</span>
<span class="o">}</span>
</pre></table></code></div></div><p>可以看到该方法在属性赋值方法内，但是在真正执行赋值操作之前。其返回值为boolean，返回false时可以阻断属性赋值阶段（<code class="language-plaintext highlighter-rouge">continueWithPropertyPopulation = false;</code>）。</p><p>关于BeanPostProcessor执行阶段的源码穿插在下文Aware接口的调用时机分析中，因为部分Aware功能的就是通过他实现的!只需要先记住BeanPostProcessor在初始化前后调用就可以了。</p><h3 id="beanpostprocessor"><span class="mr-2">BeanPostProcessor</span><a href="#beanpostprocessor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>BeanPostProcessor 是 Spring 为修改 bean提供的强大扩展点，其可作用于容器中所有 bean，其定义如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">BeanPostProcessor</span> <span class="o">{</span>

	<span class="c1">// 初始化前置处理</span>
	<span class="k">default</span> <span class="nc">Object</span> <span class="nf">postProcessBeforeInitialization</span><span class="o">(</span><span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">bean</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="c1">// 初始化后置处理</span>
	<span class="k">default</span> <span class="nc">Object</span> <span class="nf">postProcessAfterInitialization</span><span class="o">(</span><span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">bean</span><span class="o">;</span>
	<span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p>常用场景有：</p><ul><li>对于标记接口的实现类，进行自定义处理。例如3.1节中所说的ApplicationContextAwareProcessor，为其注入相应依赖；再举个例子，自定义对实现解密接口的类，将对其属性进行解密处理；<li>为当前对象提供代理实现。例如 Spring AOP 功能，生成对象的代理类，然后返回。</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// AbstractAutoProxyCreator.java</span>
<span class="kd">public</span> <span class="nc">Object</span> <span class="nf">postProcessBeforeInstantiation</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;?&gt;</span> <span class="n">beanClass</span><span class="o">,</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">TargetSource</span> <span class="n">targetSource</span> <span class="o">=</span> <span class="n">getCustomTargetSource</span><span class="o">(</span><span class="n">beanClass</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">targetSource</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasLength</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">targetSourcedBeans</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="nc">Object</span><span class="o">[]</span> <span class="n">specificInterceptors</span> <span class="o">=</span> <span class="n">getAdvicesAndAdvisorsForBean</span><span class="o">(</span><span class="n">beanClass</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">targetSource</span><span class="o">);</span>
        <span class="nc">Object</span> <span class="n">proxy</span> <span class="o">=</span> <span class="n">createProxy</span><span class="o">(</span><span class="n">beanClass</span><span class="o">,</span> <span class="n">beanName</span><span class="o">,</span> <span class="n">specificInterceptors</span><span class="o">,</span> <span class="n">targetSource</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">proxyTypes</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cacheKey</span><span class="o">,</span> <span class="n">proxy</span><span class="o">.</span><span class="na">getClass</span><span class="o">());</span>
        <span class="c1">// 返回代理类</span>
        <span class="k">return</span> <span class="n">proxy</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="第二大类只调用一次的接口"><span class="mr-2">第二大类：只调用一次的接口</span><a href="#第二大类只调用一次的接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>这一大类接口的特点是功能丰富，常用于用户自定义扩展。 第二大类中又可以分为两类：</p><ul><li>Aware类型的接口<li>生命周期接口</ul><h3 id="无所不知的aware"><span class="mr-2">无所不知的Aware</span><a href="#无所不知的aware" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Aware类型的接口的作用就是让我们能够拿到Spring容器中的一些资源。基本都能够见名知意，Aware之前的名字就是可以拿到什么资源，例如<code class="language-plaintext highlighter-rouge">BeanNameAware</code>可以拿到BeanName，以此类推。调用时机需要注意：所有的Aware方法都是在初始化阶段之前调用的！</p><p>若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以通过让bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源。</p><p>Spring 中提供的 Aware 接口有：</p><ul><li>BeanNameAware：注入当前 bean 对应 beanName；<li>BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader；<li>BeanFactoryAware：注入 当前BeanFactory容器 的引用。</ul><p>其代码实现如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// AbstractAutowireCapableBeanFactory.java</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">invokeAwareMethods</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">bean</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">Aware</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">BeanNameAware</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">((</span><span class="nc">BeanNameAware</span><span class="o">)</span> <span class="n">bean</span><span class="o">).</span><span class="na">setBeanName</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">BeanClassLoaderAware</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">((</span><span class="nc">BeanClassLoaderAware</span><span class="o">)</span> <span class="n">bean</span><span class="o">).</span><span class="na">setBeanClassLoader</span><span class="o">(</span><span class="n">bcl</span><span class="o">);</span>
            
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">BeanFactoryAware</span><span class="o">)</span> <span class="o">{</span>
            <span class="o">((</span><span class="nc">BeanFactoryAware</span><span class="o">)</span> <span class="n">bean</span><span class="o">).</span><span class="na">setBeanFactory</span><span class="o">(</span><span class="nc">AbstractAutowireCapableBeanFactory</span><span class="o">.</span><span class="na">this</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>以上是针对 BeanFactory 类型的容器，而对于 ApplicationContext 类型的容器，也提供了 Aware 接口，只不过这些 Aware 接口的注入实现，是通过 BeanPostProcessor 的方式注入的，但其作用仍是注入依赖。</p><ul><li>EnvironmentAware：注入 Enviroment，一般用于获取配置属性；<li>EmbeddedValueResolverAware：注入 EmbeddedValueResolver（Spring EL解析器），一般用于参数解析；<li>ApplicationContextAware（ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware）：注入 ApplicationContext 容器本身。 这几个接口可能让人有点懵，实际上这几个接口可以一起记，其返回值实质上都是当前的ApplicationContext对象，因为ApplicationContext是一个复合接口，如下：<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ApplicationContext</span> <span class="kd">extends</span> <span class="nc">EnvironmentCapable</span><span class="o">,</span> <span class="nc">ListableBeanFactory</span><span class="o">,</span> <span class="nc">HierarchicalBeanFactory</span><span class="o">,</span> <span class="nc">MessageSource</span><span class="o">,</span> <span class="nc">ApplicationEventPublisher</span><span class="o">,</span> <span class="nc">ResourcePatternResolver</span> <span class="o">{}</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><div><p>这里涉及ApplicationContext和BeanFactory的区别，可以从ApplicationContext继承的这几个接口入手，除去BeanFactory相关的两个接口就是ApplicationContext独有的功能，这里不详细说明。</p></div></blockquote></ul><p>其代码实现如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// ApplicationContextAwareProcessor.java</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">invokeAwareInterfaces</span><span class="o">(</span><span class="nc">Object</span> <span class="n">bean</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">EnvironmentAware</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">((</span><span class="nc">EnvironmentAware</span><span class="o">)</span><span class="n">bean</span><span class="o">).</span><span class="na">setEnvironment</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span><span class="o">.</span><span class="na">getEnvironment</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">EmbeddedValueResolverAware</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">((</span><span class="nc">EmbeddedValueResolverAware</span><span class="o">)</span><span class="n">bean</span><span class="o">).</span><span class="na">setEmbeddedValueResolver</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">embeddedValueResolver</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">ResourceLoaderAware</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">((</span><span class="nc">ResourceLoaderAware</span><span class="o">)</span><span class="n">bean</span><span class="o">).</span><span class="na">setResourceLoader</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">ApplicationEventPublisherAware</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">((</span><span class="nc">ApplicationEventPublisherAware</span><span class="o">)</span><span class="n">bean</span><span class="o">).</span><span class="na">setApplicationEventPublisher</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">MessageSourceAware</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">((</span><span class="nc">MessageSourceAware</span><span class="o">)</span><span class="n">bean</span><span class="o">).</span><span class="na">setMessageSource</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">bean</span> <span class="k">instanceof</span> <span class="nc">ApplicationContextAware</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">((</span><span class="nc">ApplicationContextAware</span><span class="o">)</span><span class="n">bean</span><span class="o">).</span><span class="na">setApplicationContext</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">applicationContext</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>Aware调用时机源码分析</strong></p><p>详情如下，忽略了部分无关代码。代码位置就是我们上文提到的initializeBean方法详情，这也说明了Aware都是在初始化阶段之前调用的！</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>    <span class="c1">// 见名知意，初始化阶段调用的方法</span>
    <span class="kd">protected</span> <span class="nc">Object</span> <span class="nf">initializeBean</span><span class="o">(</span><span class="kd">final</span> <span class="nc">String</span> <span class="n">beanName</span><span class="o">,</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">bean</span><span class="o">,</span> <span class="nd">@Nullable</span> <span class="nc">RootBeanDefinition</span> <span class="n">mbd</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 这里调用的是Group1中的三个Bean开头的Aware</span>
        <span class="n">invokeAwareMethods</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">bean</span><span class="o">);</span>

        <span class="nc">Object</span> <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">bean</span><span class="o">;</span>
        
        <span class="c1">// 这里调用的是Group2中的几个Aware，</span>
        <span class="c1">// 而实质上这里就是前面所说的BeanPostProcessor的调用点！</span>
        <span class="c1">// 也就是说与Group1中的Aware不同，这里是通过BeanPostProcessor（ApplicationContextAwareProcessor）实现的。</span>
        <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">applyBeanPostProcessorsBeforeInitialization</span><span class="o">(</span><span class="n">wrappedBean</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>
        <span class="c1">// 下文即将介绍的InitializingBean调用点</span>
        <span class="n">invokeInitMethods</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">wrappedBean</span><span class="o">,</span> <span class="n">mbd</span><span class="o">);</span>
        <span class="c1">// BeanPostProcessor的另一个调用点</span>
        <span class="n">wrappedBean</span> <span class="o">=</span> <span class="n">applyBeanPostProcessorsAfterInitialization</span><span class="o">(</span><span class="n">wrappedBean</span><span class="o">,</span> <span class="n">beanName</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">wrappedBean</span><span class="o">;</span>
    <span class="o">}</span>
</pre></table></code></div></div><p>可以看到并不是所有的Aware接口都使用同样的方式调用。Bean××Aware都是在代码中直接调用的，而ApplicationContext相关的Aware都是通过BeanPostProcessor#postProcessBeforeInitialization()实现的。感兴趣的可以自己看一下ApplicationContextAwareProcessor这个类的源码，就是判断当前创建的Bean是否实现了相关的Aware方法，如果实现了会调用回调方法将资源传递给Bean。 至于Spring为什么这么实现，应该没什么特殊的考量。也许和Spring的版本升级有关。基于对修改关闭，对扩展开放的原则，Spring对一些新的Aware采用了扩展的方式添加。</p><p>BeanPostProcessor的调用时机也能在这里体现，包围住invokeInitMethods方法，也就说明了在初始化阶段的前后执行。</p><p>关于Aware接口的执行顺序，其实只需要记住针对 BeanFactory 类型容器的Aware接口在针对 ApplicationContext 类型容器的Aware接口执行之前就行了</p><h3 id="生命周期接口"><span class="mr-2">生命周期接口</span><a href="#生命周期接口" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>至于剩下的两个生命周期接口就很简单了，实例化和属性赋值都是Spring帮助我们做的，能够自己实现的有初始化和销毁两个生命周期阶段。</p><h4 id="initializingbean-和-init-method"><span class="mr-2">InitializingBean 和 init-method</span><a href="#initializingbean-和-init-method" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>InitializingBean 和 init-method 是 Spring 为 bean 初始化提供的扩展点。</p><blockquote class="prompt-tip"><div><p>InitializingBean 对应生命周期的初始化阶段，在上面源码的<code class="language-plaintext highlighter-rouge">invokeInitMethods(beanName, wrappedBean, mbd);</code>方法中调用。</p></div></blockquote><p>InitializingBean接口 的定义如下：</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">InitializingBean</span> <span class="o">{</span>
	<span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>在 afterPropertiesSet() 方法写初始化逻辑。</p><p>指定 init-method 方法，指定初始化方法：</p><div class="language-xml highlighter-rouge"><div class="code-header"> <span data-label-text="XML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;beans</span> <span class="na">xmlns=</span><span class="s">"http://www.springframework.org/schema/beans"</span>
       <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
       <span class="na">xsi:schemaLocation=</span><span class="s">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="nt">&gt;</span>

    <span class="nt">&lt;bean</span> <span class="na">id=</span><span class="s">"demo"</span> <span class="na">class=</span><span class="s">"com.chaycao.Demo"</span> <span class="na">init-method=</span><span class="s">"init()"</span><span class="nt">/&gt;</span>
    
<span class="nt">&lt;/beans&gt;</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><div><p>有一点需要注意，因为Aware方法都是执行在初始化方法之前，所以可以在初始化方法中放心大胆的使用Aware接口获取的资源，这也是我们自定义扩展Spring的常用方式。 除了实现InitializingBean接口之外还能通过注解或者xml配置的方式指定初始化方法，至于这几种定义方式的调用顺序其实没有必要记。因为这几个方法对应的都是同一个生命周期，只是实现方式不同，我们一般只采用其中一种方式。</p></div></blockquote><h4 id="disposablebean-和-destory-method"><span class="mr-2">DisposableBean 和 destory-method</span><a href="#disposablebean-和-destory-method" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>DisposableBean 类似于InitializingBean，对应生命周期的销毁阶段，以ConfigurableApplicationContext#close()方法作为入口，实现是通过循环取所有实现了DisposableBean接口的Bean然后调用其destroy()方法, DisposableBean 和 destory-method 与上述类似</p><h1 id="总结">总结</h1><p>Spring Bean的生命周期分为<code class="language-plaintext highlighter-rouge">四个阶段</code>和<code class="language-plaintext highlighter-rouge">多个扩展点</code>。扩展点又可以分为影响多个Bean和影响单个Bean。整理如下：</p><p>四个阶段</p><ul><li>实例化 Instantiation<li>属性赋值 Populate<li>初始化 Initialization<li>销毁 Destruction</ul><p>多个扩展点</p><ul><li>影响多个Bean<ul><li>BeanPostProcessor<li>InstantiationAwareBeanPostProcessor</ul><li>影响单个Bean<ul><li>Aware<ul><li>BeanFactory 类型容器的Aware接口<ul><li>BeanNameAware<li>BeanClassLoaderAware<li>BeanFactoryAware</ul><li>ApplicationContext 类型容器的Aware接口<ul><li>EnvironmentAware<li>EmbeddedValueResolverAware<li>ApplicationContextAware(ResourceLoaderAware\ApplicationEventPublisherAware\MessageSourceAware)</ul></ul><li>生命周期<ul><li>InitializingBean<li>DisposableBean</ul></ul></ul><p>扩展点按生命周期划分</p><ul><li>初始化的具体操作，有 Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及 InitializingBean 和 init-method 的初始化操作；<li>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</ul><h1 id="参考">参考</h1><ul><li><a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F1dec08d290c1">请别再问Spring Bean的生命周期了！</a><li><a href="https://juejin.cn/post/6844903682673229831">聊聊spring的那些扩展机制</a><li><a href="https://juejin.cn/post/6844904065457979405">如何记忆 Spring Bean 的生命周期</a></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/software-development/'>Software Development</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a> <a href="/tags/spring/" class="post-tag no-text-decoration" >Spring</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://t.me/share/url?url=https://optimus-xs.github.io/posts/spring-bean-s-lifecycle/&amp;text=Spring Bean 的生命周期 - Optimus-Xs&#39; Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://optimus-xs.github.io/posts/spring-bean-s-lifecycle/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/how-to-write-a-dockerfile-elegantly/">如何优雅的编写Dockerfile</a><li><a href="/posts/java-file-io-usage/">Java 文件 IO 使用方法</a><li><a href="/posts/jvm-gc-mechanism/">JVM 的垃圾回收机制</a><li><a href="/posts/docker-engine-installation-on-ubuntu/">在 Ubuntu 上安装 Dockers Engine 流程</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/devdairy/">DevDairy</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a> <a class="post-tag" href="/tags/geekdairy/">GeekDairy</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/why-autowired-not-recommended/"><div class="card-body"> <em class="timeago small" data-ts="1602220140" > 2020-10-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>为什么使用 @Autowired 提示不推荐</h3><div class="text-muted small"><p> @Autowired注解相信每个Spring开发者都不陌生了！ 但是当我们使用IDEA写代码的时候，经常会发现@Autowired注解下面是有小黄线的，我们把小鼠标悬停在上面，可以看到这个如下图所示的警告信息： 那么为什么IDEA会给出Field injection is not recommended这样的警告呢？ 下面带着这样的问题，一起来全面的了解下Spring中的三种注入方...</p></div></div></a></div><div class="card"> <a href="/posts/spring-security-usage/"><div class="card-body"> <em class="timeago small" data-ts="1614408060" > 2021-02-27 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>SpringSecurity 使用方法</h3><div class="text-muted small"><p> 简介 Spring Security 是一个相对复杂的安全管理框架，功能比 Shiro 更加强大，权限控制细粒度更高，对 OAuth 2 的支持也更友好。 由于 Spring Security 源自 Spring 家族，因此可以和 Spring 框架无缝整合，特别是 Spring Boot 中提供的自动化配置方案，可以让 Spring Security 的使用更加便捷。 依赖配置 &amp;lt;...</p></div></div></a></div><div class="card"> <a href="/posts/spring-integrate-jwt-auth/"><div class="card-body"> <em class="timeago small" data-ts="1614609960" > 2021-03-01 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>SpringSecurity 集成JWT权限验证</h3><div class="text-muted small"><p> 一般来讲，对于RESTful API都会有认证(Authentication)和授权(Authorization)过程，保证API的安全性。 Authentication指的是确定这个用户的身份，Authorization是确定该用户拥有什么操作权限。 认证方式一般有三种 Basic Authentication 这种方式是直接将用户名和密码放到Header中，使用Autho...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/java-dynamic-proxy-implementation-methods/" class="btn btn-outline-primary" prompt="上一篇"><p>Java 动态代理实现方法</p></a> <a href="/posts/jvm-class-loading-mechanism/" class="btn btn-outline-primary" prompt="下一篇"><p>JVM类加载机制</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Optimus-Xs">Optimus-Xs</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/devdairy/">DevDairy</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a> <a class="post-tag" href="/tags/geekdairy/">GeekDairy</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh-cn.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>

<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="zh-cn"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Java 多线程概览" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="前言 用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。" /><meta property="og:description" content="前言 用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。" /><link rel="canonical" href="https://optimus-xs.github.io/posts/java-multithreading-overview/" /><meta property="og:url" content="https://optimus-xs.github.io/posts/java-multithreading-overview/" /><meta property="og:site_name" content="Optimus-Xs’ Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-11-27T16:43:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Java 多线程概览" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="VWHcsZQRCRLxZT171OOZpP1emj_N4gMlSvgq8UReWz4" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-11-27T16:43:00+08:00","datePublished":"2020-11-27T16:43:00+08:00","description":"前言 用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。","headline":"Java 多线程概览","mainEntityOfPage":{"@type":"WebPage","@id":"https://optimus-xs.github.io/posts/java-multithreading-overview/"},"url":"https://optimus-xs.github.io/posts/java-multithreading-overview/"}</script><title>Java 多线程概览 | Optimus-Xs' Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Optimus-Xs' Blog"><meta name="application-name" content="Optimus-Xs' Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/miTu.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Optimus-Xs' Blog</a></div><div class="site-subtitle font-italic">「Think Different」</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Optimus-Xs" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['Wenlong.Zuo','outlook.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Java 多线程概览</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Java 多线程概览</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/Optimus-Xs">Optimus-Xs</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1606466580" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2020-11-27 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="11836 字"> <em>65 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="前言">前言</h1><p>用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。</p><p>其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。</p><ul><li>多线程：指的是这个程序（一个进程）运行时产生了不止一个线程<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。<li>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码<div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">transferMoney</span><span class="o">(</span><span class="nc">User</span> <span class="n">from</span><span class="o">,</span> <span class="nc">User</span> <span class="n">to</span><span class="o">,</span> <span class="kt">float</span> <span class="n">amount</span><span class="o">){</span>
<span class="n">to</span><span class="o">.</span><span class="na">setMoney</span><span class="o">(</span><span class="n">to</span><span class="o">.</span><span class="na">getBalance</span><span class="o">()</span> <span class="o">+</span> <span class="n">amount</span><span class="o">);</span>
<span class="n">from</span><span class="o">.</span><span class="na">setMoney</span><span class="o">(</span><span class="n">from</span><span class="o">.</span><span class="na">getBalance</span><span class="o">()</span> <span class="o">-</span> <span class="n">amount</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><li>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</ul><h1 id="什么是java多线程">什么是Java多线程?</h1><h2 id="进程与线程"><span class="mr-2">进程与线程</span><a href="#进程与线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>进程</p><ul><li>当一个程序被运行，就开启了一个进程， 比如启动了qq，word<li>程序由指令和数据组成，指令要运行，数据要加载，指令被cpu加载运行，数据被加载到内存，指令运行时可由cpu调度硬盘、网络等设备</ul><p>线程</p><ul><li>一个进程内可分为多个线程<li>一个线程就是一个指令流，cpu调度的最小单位，由cpu一条一条执行指令</ul><h2 id="并行与并发"><span class="mr-2">并行与并发</span><a href="#并行与并发" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>并发：单核cpu运行多线程时，时间片进行很快的切换。线程轮流执行cpu</p><p>并行：多核cpu运行 多线程时，真正的在同一时刻运行</p><p><img data-src="https://i.ibb.co/k2HXt2R/a-HR0c-HM6-Ly9w-OS1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C84-MWU5-OWUx-ODk3.png" alt="并发对比并行" data-proofer-ignore></p><p>Java提供了丰富的api来支持多线程。</p><h1 id="为什么用多线程">为什么用多线程?</h1><p>多线程能实现的都可以用单线程来完成，那单线程运行的好好的，为什么Java要引入多线程的概念呢？</p><p>多线程的好处：</p><ul><li>程序运行的更快！快！快！<li>充分利用cpu资源，目前几乎没有线上的cpu是单核的，发挥多核cpu强大的能力</ul><h1 id="多线程难在哪里">多线程难在哪里？</h1><p>单线程只有一条执行线，过程容易理解，可以在大脑中清晰的勾勒出代码的执行流程</p><p>多线程却是多条线，而且一般多条线之间有交互，多条线之间需要通信，一般难点有以下几点</p><ul><li>多线程的执行结果不确定,受到cpu调度的影响<li>多线程的安全问题<li>线程资源宝贵，依赖线程池操作线程，线程池的参数设置问题<li>多线程执行是动态的，同时的,难以追踪过程<li>多线程的底层是操作系统层面的，源码难度大</ul><h1 id="java多线程的基本使用">Java多线程的基本使用</h1><h2 id="定义任务创建和运行线程"><span class="mr-2">定义任务、创建和运行线程</span><a href="#定义任务创建和运行线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>任务： 线程的执行体。也就是我们的核心代码逻辑</p><p>定义任务</p><ul><li>继承Thread类 （可以说是 将任务和线程合并在一起）<li>实现Runnable接口 （可以说是 将任务和线程分开了）<li>实现Callable接口 (利用FutureTask执行任务)</ul><p>Thread实现任务的局限性</p><ul><li>任务逻辑写在Thread类的run方法中，有单继承的局限性<li>创建多线程时，每个任务有成员变量时不共享，必须加static才能做到共享</ul><p>Runnable和Callable解决了Thread的局限性</p><p>但是Runbale相比Callable有以下的局限性</p><ul><li>任务没有返回值<li>任务无法抛异常给调用方</ul><p>如下代码 几种定义线程的方式</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="nd">@Slf4j</span>
<span class="kd">class</span> <span class="nc">T</span> <span class="kd">extends</span> <span class="nc">Thread</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"我是继承Thread的任务"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Slf4j</span>
<span class="kd">class</span> <span class="nc">R</span> <span class="kd">implements</span> <span class="nc">Runnable</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"我是实现Runnable的任务"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nd">@Slf4j</span>
<span class="kd">class</span> <span class="nc">C</span> <span class="kd">implements</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">call</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"我是实现Callable的任务"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"success"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>创建线程的方式</p><ul><li>通过Thread类直接创建线程<li>利用线程池内部创建线程</ul><p>启动线程的方式</p><p>调用线程的start()方法</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="c1">// 启动继承Thread类的任务</span>
<span class="k">new</span> <span class="nf">T</span><span class="o">().</span><span class="na">start</span><span class="o">();</span>

<span class="c1">// 启动继承Thread匿名内部类的任务 可用lambda优化</span>
<span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(){</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"我是Thread匿名内部类的任务"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">};</span>

<span class="c1">//  启动实现Runnable接口的任务</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="no">R</span><span class="o">()).</span><span class="na">start</span><span class="o">();</span>

<span class="c1">//  启动实现Runnable匿名实现类的任务</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="k">new</span> <span class="nc">Runnable</span><span class="o">()</span> <span class="o">{</span>
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"我是Runnable匿名内部类的任务"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}).</span><span class="na">start</span><span class="o">();</span>

<span class="c1">//  启动实现Runnable的lambda简化后的任务</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"我是Runnable的lambda简化后的任务"</span><span class="o">)).</span><span class="na">start</span><span class="o">();</span>

<span class="c1">// 启动实现了Callable接口的任务 结合FutureTask 可以获取线程执行的结果</span>
<span class="nc">FutureTask</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">target</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">FutureTask</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="no">C</span><span class="o">());</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="o">(</span><span class="n">target</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="n">target</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
</pre></table></code></div></div><p>以上各个线程相关的类的类图如下</p><p><img data-src="https://i.ibb.co/SyfScfN/a-HR0c-HM6-Ly9w-MS1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C9l-Zj-U0-Yj-Qy-Zj.png" alt="线程相关的类的类图" data-proofer-ignore></p><h2 id="上下文切换"><span class="mr-2">上下文切换</span><a href="#上下文切换" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>多核cpu下，多线程是并行工作的，如果线程数多，单个核又会并发的调度线程,运行时会有上下文切换的概念</p><p>cpu执行线程的任务时，会为线程分配时间片，以下几种情况会发生上下文切换。</p><ul><li>线程的cpu时间片用完<li>垃圾回收<li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</ul><p>当发生上下文切换时，操作系统会保存当前线程的状态，并恢复另一个线程的状态,jvm中有块内存地址叫程序计数器，用于记录线程执行到哪一行代码,是线程私有的。</p><h2 id="线程的礼让-yield线程的优先级"><span class="mr-2">线程的礼让-yield()&amp;线程的优先级</span><a href="#线程的礼让-yield线程的优先级" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>yield()方法会让运行中的线程切换到就绪状态，重新争抢cpu的时间片，争抢时是否获取到时间片看cpu的分配。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">yield</span><span class="o">();</span>

<span class="nc">Runnable</span> <span class="n">r1</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(;;){</span>
       <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"---- 1&gt;"</span> <span class="o">+</span> <span class="n">count</span><span class="o">++);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">Runnable</span> <span class="n">r2</span> <span class="o">=</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(;;){</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">yield</span><span class="o">();</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"            ---- 2&gt;"</span> <span class="o">+</span> <span class="n">count</span><span class="o">++);</span>
    <span class="o">}</span>
<span class="o">};</span>
<span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">r1</span><span class="o">,</span><span class="s">"t1"</span><span class="o">);</span>
<span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(</span><span class="n">r2</span><span class="o">,</span><span class="s">"t2"</span><span class="o">);</span>
<span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
</pre></table></code></div></div><p>运行结果</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129504
11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129505
11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129506
11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129507
11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129508
11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129509
11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129510
11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129511
11:49:15.796 [t1] INFO thread.TestYield - ---- 1&gt;129512
11:49:15.798 [t2] INFO thread.TestYield -             ---- 2&gt;293
11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129513
11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129514
11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129515
11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129516
11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129517
11:49:15.798 [t1] INFO thread.TestYield - ---- 1&gt;129518
</pre></table></code></div></div><p>如上述结果所示，t2线程每次执行时进行了yield()，线程1执行的机会明显比线程2要多。</p><h2 id="线程的优先级"><span class="mr-2">线程的优先级</span><a href="#线程的优先级" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>​ 线程内部用1~10的数来调整线程的优先级，默认的线程优先级为NORM_PRIORITY:5</p><p>​ cpu比较忙时，优先级高的线程获取更多的时间片</p><p>​ cpu比较闲时，优先级设置基本没用</p><h2 id="守护线程"><span class="mr-2">守护线程</span><a href="#守护线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>默认情况下，Java进程需要等待所有线程都运行结束，才会结束，有一种特殊线程叫守护线程，当所有的非守护线程都结束后，即使它没有执行完，也会强制结束。</p><p>默认的线程都是非守护线程。</p><p>垃圾回收线程就是典型的守护线程</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="c1">// 方法的定义</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">setDaemon</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">on</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>

<span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">}</span>
<span class="o">});</span>
<span class="c1">// 具体的api。设为true表示未守护线程，当主线程结束后，守护线程也结束。</span>
<span class="c1">// 默认是false，当主线程结束后，thread继续运行，程序不停止</span>
<span class="n">thread</span><span class="o">.</span><span class="na">setDaemon</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="n">thread</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"结束"</span><span class="o">);</span>
</pre></table></code></div></div><h2 id="线程的阻塞"><span class="mr-2">线程的阻塞</span><a href="#线程的阻塞" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>线程的阻塞可以分为好多种，从操作系统层面和Java层面阻塞的定义可能不同，但是广义上使得线程阻塞的方式有下面几种</p><ul><li>BIO阻塞，即使用了阻塞式的io流<li>sleep(long time) 让线程休眠进入阻塞状态<li>a.join() 调用该方法的线程进入阻塞，等待a线程执行完恢复运行<li>sychronized或ReentrantLock 造成线程未获得锁进入阻塞状态 (同步锁章节细说)<li>获得锁之后调用wait()方法 也会让线程进入阻塞状态 (同步锁章节细说)<li>LockSupport.park() 让线程进入阻塞状态 (同步锁章节细说)</ul><h3 id="sleep"><span class="mr-2">sleep()</span><a href="#sleep" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>使线程休眠，会将运行中的线程进入阻塞状态。当休眠时间结束后，重新争抢cpu的时间片继续运行</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// 方法的定义 native方法</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">;</span> 

<span class="k">try</span> <span class="o">{</span>
   <span class="c1">// 休眠2秒</span>
   <span class="c1">// 该方法会抛出 InterruptedException异常 即休眠过程中可被中断，被中断后抛出异常</span>
   <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
 <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException异常</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
 <span class="o">}</span>
 <span class="k">try</span> <span class="o">{</span>
   <span class="c1">// 使用TimeUnit的api可替代 Thread.sleep </span>
   <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
 <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
 <span class="o">}</span>
</pre></table></code></div></div><h3 id="join"><span class="mr-2">join()</span><a href="#join" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>​join是指调用该方法的线程进入阻塞状态，等待某线程执行完成后恢复运行</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 方法的定义 有重载</span>
<span class="c1">// 等待线程执行完才恢复运行</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">join</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
<span class="o">}</span>
<span class="c1">// 指定join的时间。指定时间内 线程还未执行完 调用方线程不继续等待就恢复运行</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">join</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">)</span>
    <span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">{}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
<span class="o">});</span>

<span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
<span class="c1">// 让主线程阻塞 等待t线程执行完才继续执行 </span>
<span class="c1">// 去除该行，执行结果为0，加上该行 执行结果为10</span>
<span class="n">t</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"r:{}"</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
</pre></table></code></div></div><p>运行结果</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>13:09:13.892 [main] INFO thread.TestJoin - r:10
</pre></table></code></div></div><h2 id="线程的打断-interrupt"><span class="mr-2">线程的打断-interrupt()</span><a href="#线程的打断-interrupt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 相关方法的定义</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">interrupt</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isInterrupted</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">interrupted</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>
</pre></table></code></div></div><p>打断标记：线程是否被打断，true表示被打断了，false表示没有</p><p>isInterrupted() 获取线程的打断标记 ,调用后不会修改线程的打断标记</p><p>interrupt()方法用于中断线程</p><ul><li>可以打断sleep,wait,join等显式的抛出InterruptedException方法的线程，但是打断后,线程的打断标记还是false<li>打断正常线程 ，线程不会真正被中断，但是线程的打断标记为true</ul><p>interrupted() 获取线程的打断标记，调用后清空打断标记 即如果获取为true 调用后打断标记为false (不常用)</p><p>interrupt实例： 有个后台监控线程不停的监控，当外界打断它时，就结束运行。代码如下</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="nd">@Slf4j</span>
<span class="kd">class</span> <span class="nc">TwoPhaseTerminal</span><span class="o">{</span>
    <span class="c1">// 监控线程</span>
    <span class="kd">private</span> <span class="nc">Thread</span> <span class="n">monitor</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">(){</span>
        <span class="n">monitor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;{</span>
           <span class="c1">// 不停的监控</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">){</span>
                <span class="nc">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
             	<span class="c1">// 判断当前线程是否被打断</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">thread</span><span class="o">.</span><span class="na">isInterrupted</span><span class="o">()){</span>
                    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"当前线程被打断,结束运行"</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
                	<span class="c1">// 监控逻辑中被打断后，打断标记为true</span>
                    <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"监控"</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// 睡眠时被打断时抛出异常 在该处捕获到 此时打断标记还是false</span>
                    <span class="c1">// 在调用一次中断 使得中断标记为true</span>
                    <span class="n">thread</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="n">monitor</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">(){</span>
        <span class="n">monitor</span><span class="o">.</span><span class="na">interrupt</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="线程的状态"><span class="mr-2">线程的状态</span><a href="#线程的状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>上面说了一些基本的api的使用，调用上面的方法后都会使得线程有对应的状态。</p><p>线程的状态可从 操作系统层面分为五种状态 从Java api层面分为六种状态。</p><h3 id="五种状态"><span class="mr-2">五种状态</span><a href="#五种状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="https://i.ibb.co/Hq3WS80/M44-KQ8-VFEG1216-MTJ9-Q9-GK3-ID.png" alt="线程五种状态" data-proofer-ignore></p><ol><li>初始状态：创建线程对象时的状态<li>可运行状态(就绪状态)：调用start()方法后进入就绪状态，也就是准备好被cpu调度执行<li>运行状态：线程获取到cpu的时间片，执行run()方法的逻辑<li>阻塞状态: 线程被阻塞，放弃cpu的时间片，等待解除阻塞重新回到就绪状态争抢时间片<li>终止状态: 线程执行完成或抛出异常后的状态</ol><h3 id="六种状态"><span class="mr-2">六种状态</span><a href="#六种状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><img data-src="https://i.ibb.co/1nqFD2n/1689841-383f7101e6588094.png" alt="线程六种状态" data-proofer-ignore></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">State</span> <span class="o">{</span>
	<span class="no">NEW</span><span class="o">,</span>
	<span class="no">RUNNABLE</span><span class="o">,</span>
	<span class="no">BLOCKED</span><span class="o">,</span>
	<span class="no">WAITING</span><span class="o">,</span>
	<span class="no">TIMED_WAITING</span><span class="o">,</span>
	<span class="no">TERMINATED</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>六种线程状态和方法的对应关系 <img data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMy1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC82MjI2NTkzMzdmY2E0NDZjOGNjYjRkZTZjMjZiMTJiNX50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png" alt="线程六种状态方法" data-proofer-ignore></p><ol><li>NEW 线程对象被创建<li>Runnable 线程调用了start()方法后进入该状态，该状态包含了三种情况<ol><li>就绪状态 :等待cpu分配时间片<li>运行状态:进入Runnable方法执行任务<li>阻塞状态:BIO 执行阻塞式io流时的状态</ol><li>Blocked 没获取到锁时的阻塞状态(同步锁章节会细说)<li>WAITING（等待） 调用wait()、join()等方法后的状态<li>TIMED_WAITING（锁定） 调用 sleep(time)、wait(time)、join(time)等方法后的状态<li>TERMINATED 线程执行完成或抛出异常后的状态</ol><h2 id="线程的相关方法总结"><span class="mr-2">线程的相关方法总结</span><a href="#线程的相关方法总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>主要总结Thread类中的核心方法</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">方法名称<th style="text-align: left">是否static<th style="text-align: left">方法说明<tbody><tr><td style="text-align: left">start()<td style="text-align: left">否<td style="text-align: left">让线程启动，进入就绪状态,等待cpu分配时间片<tr><td style="text-align: left">run()<td style="text-align: left">否<td style="text-align: left">重写Runnable接口的方法,线程获取到cpu时间片时执行的具体逻辑<tr><td style="text-align: left">yield()<td style="text-align: left">是<td style="text-align: left">线程的礼让，使得获取到cpu时间片的线程进入就绪状态，重新争抢时间片<tr><td style="text-align: left">sleep(time)<td style="text-align: left">是<td style="text-align: left">线程休眠固定时间，进入阻塞状态，休眠时间完成后重新争抢时间片,休眠可被打断<tr><td style="text-align: left">join()/join(time)<td style="text-align: left">否<td style="text-align: left">调用线程对象的join方法，调用者线程进入阻塞,等待线程对象执行完或者到达指定时间才恢复，重新争抢时间片<tr><td style="text-align: left">isInterrupted()<td style="text-align: left">否<td style="text-align: left">获取线程的打断标记，true:被打断，false：没有被打断。调用后不会修改打断标记<tr><td style="text-align: left">interrupt()<td style="text-align: left">否<td style="text-align: left">打断线程，抛出InterruptedException异常的方法均可被打断，但是打断后不会修改打断标记，正常执行的线程被打断后会修改打断标记<tr><td style="text-align: left">interrupted()<td style="text-align: left">否<td style="text-align: left">获取线程的打断标记。调用后会清空打断标记<tr><td style="text-align: left">stop()<td style="text-align: left">否<td style="text-align: left">停止线程运行 不推荐<tr><td style="text-align: left">suspend()<td style="text-align: left">否<td style="text-align: left">挂起线程 不推荐<tr><td style="text-align: left">resume()<td style="text-align: left">否<td style="text-align: left">恢复线程运行 不推荐<tr><td style="text-align: left">currentThread()<td style="text-align: left">是<td style="text-align: left">获取当前线程</table></div><p>Object中与线程相关方法</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">方法名称<th style="text-align: left">方法说明<tbody><tr><td style="text-align: left">wait()/wait(long timeout)<td style="text-align: left">获取到锁的线程进入阻塞状态<tr><td style="text-align: left">notify()<td style="text-align: left">随机唤醒被wait()的一个线程<tr><td style="text-align: left">notifyAll();<td style="text-align: left">唤醒被wait()的所有线程，重新争抢时间片</table></div><h1 id="同步锁">同步锁</h1><h2 id="线程安全"><span class="mr-2">线程安全</span><a href="#线程安全" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>一个程序运行多个线程本身是没有问题的<li>问题有可能出现在多个线程访问共享资源<ul><li>多个线程都是读共享资源也是没有问题的<li>当多个线程读写共享资源时,如果发生指令交错，就会出现问题</ul></ul><p>临界区: 一段代码如果对共享资源的多线程读写操作,这段代码就被称为临界区。</p><p>注意的是 指令交错指的是 Java代码在解析成字节码文件时，Java代码的一行代码在字节码中可能有多行，在线程上下文切换时就有可能交错。</p><p>线程安全指的是多线程调用同一个对象的临界区的方法时，对象的属性值一定不会发生错误，这就是保证了线程安全。</p><p>如下面不安全的代码</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// 对象的成员变量</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
  <span class="c1">// t1线程对变量+5000次</span>
    <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">++;</span>
        <span class="o">}</span>
    <span class="o">});</span>
  <span class="c1">// t2线程对变量-5000次</span>
    <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">count</span><span class="o">--;</span>
        <span class="o">}</span>
    <span class="o">});</span>

    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="c1">// 让t1 t2都执行完</span>
    <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 运行结果 </span>
<span class="o">-</span><span class="mi">1399</span>
</pre></table></code></div></div><blockquote class="prompt-info"><div><p>上面的代码 两个线程，一个+5000次，一个-5000次，如果线程安全，count的值应该还是0。</p><p>但是运行很多次，每次的结果不同，且都不是0，所以是线程不安全的。</p></div></blockquote><p><strong>线程安全的类一定所有的操作都线程安全吗？</strong></p><p>开发中经常会说到一些线程安全的类，如ConcurrentHashMap，线程安全指的是类里每一个独立的方法是线程安全的，但是方法的组合就不一定是线程安全的。</p><p><strong>成员变量和静态变量是否线程安全?</strong></p><ul><li>如果没有多线程共享，则线程安全<li>如果存在多线程共享<ul><li>多线程只有读操作，则线程安全<li>多线程存在写操作，写操作的代码又是临界区,则线程不安全</ul></ul><p><strong>局部变量是否线程安全?</strong></p><ul><li>局部变量是线程安全的<li>局部变量引用的对象未必是线程安全的<ul><li>如果该对象没有逃离该方法的作用范围，则线程安全<li>如果该对象逃离了该方法的作用范围，比如：方法的返回值,需要考虑线程安全</ul></ul><h2 id="synchronized"><span class="mr-2">synchronized</span><a href="#synchronized" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>同步锁也叫对象锁，是锁在对象上的，不同的对象就是不同的锁。</p><p>该关键字是用于保证线程安全的，是阻塞式的解决方案。</p><p>让同一个时刻最多只有一个线程能持有对象锁，其他线程在想获取这个对象锁就会被阻塞，不用担心上下文切换的问题。</p><p>注意： 不要理解为一个线程加了锁 ，进入 synchronized代码块中就会一直执行下去。如果时间片切换了，也会执行其他线程，再切换回来会紧接着执行，只是不会执行到有竞争锁的资源，因为当前线程还未释放锁。</p><p>当一个线程执行完synchronized的代码块后 会唤醒正在等待的线程</p><p>synchronized实际上使用对象锁保证临界区的原子性 临界区的代码是不可分割的 不会因为线程切换所打断</p><p>基本使用</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// 加在方法上 实际是对this对象加锁</span>
<span class="kd">private</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">a</span><span class="o">()</span> <span class="o">{</span>
<span class="o">}</span>

<span class="c1">// 同步代码块,锁对象可以是任意的，加在this上 和a()方法作用相同</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">b</span><span class="o">(){</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="k">this</span><span class="o">){</span>

    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 加在静态方法上 实际是对类对象加锁</span>
<span class="kd">private</span> <span class="kd">synchronized</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">c</span><span class="o">()</span> <span class="o">{</span>

<span class="o">}</span>

<span class="c1">// 同步代码块 实际是对类对象加锁 和c()方法作用相同</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">d</span><span class="o">(){</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="nc">TestSynchronized</span><span class="o">.</span><span class="na">class</span><span class="o">){</span>
        
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div file=".class" class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text=".class"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// 上述b方法对应的字节码源码 其中monitorenter就是加锁的地方</span>
<span class="n">aload_0</span>
<span class="n">dup</span>
<span class="n">astore_1</span>
<span class="n">monitorenter</span>
<span class="n">aload_1</span>
<span class="n">monitorexit</span>
<span class="k">goto</span> <span class="mi">14</span> <span class="p">(</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span>
<span class="n">astore_2</span>
<span class="n">aload_1</span>
<span class="n">monitorexit</span>
<span class="n">aload_2</span>
<span class="n">athrow</span>
<span class="k">return</span>
</pre></table></code></div></div><p>线程安全的代码</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="nc">Object</span> <span class="n">lock2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>

 <span class="c1">// t1线程和t2对象都是对同一对象加锁。保证了线程安全。此段代码无论执行多少次，结果都是0</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="nc">Thread</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="nc">Thread</span> <span class="n">t2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">count</span><span class="o">--;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">});</span>
 
    <span class="n">t1</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>

    <span class="c1">// 让t1 t2都执行完</span>
    <span class="n">t1</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="n">t2</span><span class="o">.</span><span class="na">join</span><span class="o">();</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote class="prompt-tip"><div><p>重点：加锁是加在对象上，一定要保证是同一对象，加锁才能生效</p></div></blockquote><h2 id="线程通信"><span class="mr-2">线程通信</span><a href="#线程通信" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="waitnotify"><span class="mr-2">wait+notify</span><a href="#waitnotify" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>线程间通信可以通过共享变量+wait()¬ify()来实现</p><p>wait()将线程进入阻塞状态，notify()将线程唤醒</p><p>当多线程竞争访问对象的同步方法时，锁对象会关联一个底层的Monitor对象(重量级锁的实现)</p><p>如下图所示 Thread0,1先竞争到锁执行了代码后，2,3,4,5线程同时来执行临界区的代码,开始竞争锁</p><p><img data-src="https://i.ibb.co/vv4M5jZ/a-HR0c-HM6-Ly9w-My1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C8z-Zj-A0-Zjlk-MTIw.png" alt="" data-proofer-ignore></p><ol><li>Thread-0先获取到对象的锁，关联到monitor的owner，同步代码块内调用了锁对象的wait()方法，调用后会进入waitSet等待，Thread-1同样如此，此时Thread-0的状态为Waitting<li>Thread2、3、4、5同时竞争，2获取到锁后，关联了monitor的owner，3、4、5只能进入EntryList中等待，此时2线程状态为 Runnable，3、4、5状态为Blocked<li>2执行后，唤醒entryList中的线程，3、4、5进行竞争锁，获取到的线程即会关联monitor的owner<li>3、4、5线程在执行过程中，调用了锁对象的notify()或notifyAll()时，会唤醒waitSet的线程，唤醒的线程进入entryList等待重新竞争锁</ol><p>注意:</p><ul><li>Blocked状态和Waitting状态都是阻塞状态<li>Blocked线程会在owner线程释放锁时唤醒<li>wait和notify使用场景是必须要有同步，且必须获得对象的锁才能调用,使用锁对象去调用,否则会抛异常<li>wait() 释放锁 进入 waitSet 可传入时间，如果指定时间内未被唤醒 则自动唤醒<li>notify()随机唤醒一个waitSet里的线程<li>notifyAll()唤醒waitSet中所有的线程</ul><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kd">final</span> <span class="nc">Object</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"开始执行"</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
          	<span class="c1">// 同步代码内部才能调用</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"继续执行核心逻辑"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="s">"t1"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

<span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"开始执行"</span><span class="o">);</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"继续执行核心逻辑"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">},</span> <span class="s">"t2"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

<span class="k">try</span> <span class="o">{</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
<span class="o">}</span>
<span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"开始唤醒"</span><span class="o">);</span>

<span class="kd">synchronized</span> <span class="o">(</span><span class="n">lock</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 同步代码内部才能调用</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><p>执行结果</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>14:29:47.138 [t1] INFO TestWaitNotify - 开始执行
14:29:47.141 [t2] INFO TestWaitNotify - 开始执行
14:29:49.136 [main] INFO TestWaitNotify - 开始唤醒
14:29:49.136 [t2] INFO TestWaitNotify - 继续执行核心逻辑
14:29:49.136 [t1] INFO TestWaitNotify - 继续执行核心逻辑
</pre></table></code></div></div><p><strong>wait 和 sleep的区别?</strong> 二者都会让线程进入阻塞状态，有以下区别</p><ul><li>wait是Object的方法 sleep是Thread的方法<li>wait会立即释放锁 sleep不会释放锁<li>wait后线程的状态是Watting sleep后线程的状态为 Time_Waiting</ul><h3 id="parkunpark"><span class="mr-2">park&amp;unpark</span><a href="#parkunpark" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>LockSupport是juc下的工具类，提供了park和unpark方法，可以实现线程通信</p><p><strong>与wait和notity相比的不同点</strong></p><ul><li>wait 和notify需要获取对象锁 park unpark不要<li>unpark 可以指定唤醒线程 notify随机唤醒<li>park和unpark的顺序可以先unpark wait和notify的顺序不能颠倒</ul><h2 id="生产者消费者模型"><span class="mr-2">生产者消费者模型</span><a href="#生产者消费者模型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>指的是有生产者来生产数据，消费者来消费数据，生产者生产满了就不生产了，通知消费者取，等消费了再进行生产。</p><p>消费者消费不到了就不消费了，通知生产者生产，生产到了再继续消费。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre><td class="rouge-code"><pre>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
        <span class="nc">MessageQueue</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MessageQueue</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
		
		<span class="c1">// 三个生产者向队列里存值</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="k">new</span> <span class="nc">Message</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="s">"值"</span> <span class="o">+</span> <span class="n">id</span><span class="o">));</span>
            <span class="o">},</span> <span class="s">"生产者"</span> <span class="o">+</span> <span class="n">i</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>

		<span class="c1">// 一个消费者不停的从队列里取值</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">queue</span><span class="o">.</span><span class="na">take</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">},</span> <span class="s">"消费者"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 消息队列被生产者和消费者持有</span>
<span class="kd">class</span> <span class="nc">MessageQueue</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">LinkedList</span><span class="o">&lt;</span><span class="nc">Message</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

    <span class="c1">// 容量</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">capacity</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MessageQueue</span><span class="o">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 生产
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="nc">Message</span> <span class="n">message</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">capacity</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"队列已满，生产者等待"</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">list</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"生产消息:{}"</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
            <span class="c1">// 生产后通知消费者</span>
            <span class="n">list</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Message</span> <span class="nf">take</span><span class="o">()</span> <span class="o">{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">list</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">while</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"队列已空，消费者等待"</span><span class="o">);</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">wait</span><span class="o">();</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="nc">Message</span> <span class="n">message</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">removeFirst</span><span class="o">();</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"消费消息:{}"</span><span class="o">,</span> <span class="n">message</span><span class="o">);</span>
            <span class="c1">// 消费后通知生产者</span>
            <span class="n">list</span><span class="o">.</span><span class="na">notifyAll</span><span class="o">();</span>
            <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
 <span class="c1">// 消息</span>
<span class="kd">class</span> <span class="nc">Message</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">Object</span> <span class="n">value</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="同步锁案例"><span class="mr-2">同步锁案例</span><a href="#同步锁案例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>为了更形象的表达加同步锁的概念，这里举一个生活中的例子，尽量把以上的概念具体化出来。</p><p>现实中，我们去银行门口的自动取款机取钱，取款机的钱就是共享变量，为了保障安全，不可能两个陌生人同时进入同一个取款机内取钱，所以只能一个人进入取钱，然后锁上取款机的门，其他人只能在取款机门口等待。</p><p>取款机有多个，里面的钱互不影响，锁也有多个（多个对象锁），取钱人在多个取款机里同时取钱也没有安全问题。</p><p>假如每个取钱的陌生人都是线程，当取钱人进入取款机锁了门后(线程获得锁)，取到钱后出门(线程释放锁)，下一个人竞争到锁来取钱。</p><p>假设工作人员也是一个线程,如果取钱人进入后发现取款机钱不足了，这时通知工作人员来向取款机里加钱(调用notifyAll方法)，取钱人暂停取钱，进入银行大堂阻塞等待(调用wait方法)。</p><p>银行大堂里的工作人员和取钱人都被唤醒，重新竞争锁，进入后如果是取钱人，由于取款机没钱，还得进入银行大堂等待。</p><p>当工作人员获得取款机的锁进入后，加了钱后会通知大厅里的人来取钱(调用notifyAll方法)。自己暂停加钱，进入银行大堂等待唤醒加钱(调用wait方法)。</p><p>这时大堂里等待的人都来竞争锁，谁获取到谁进入继续取钱。</p><p><img data-src="https://i.ibb.co/r7g7bTb/a-HR0c-HM6-Ly9w-MS1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C9j-Nz-Zj-MGYw-Yzhk.png" alt="" data-proofer-ignore></p><p>和现实中不同的就是这里没有排队的概念，谁抢到锁谁进去取。</p><h2 id="reentrantlock"><span class="mr-2">ReentrantLock</span><a href="#reentrantlock" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>可重入锁 : 一个线程获取到对象的锁后，执行方法内部在需要获取锁的时候是可以获取到的。如以下代码</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="no">LOCK</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">();</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">m</span><span class="o">()</span> <span class="o">{</span>
    <span class="no">LOCK</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"begin"</span><span class="o">);</span>
      	<span class="c1">// 调用m1()</span>
        <span class="n">m1</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// 注意锁的释放</span>
        <span class="no">LOCK</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">m1</span><span class="o">()</span> <span class="o">{</span>
    <span class="no">LOCK</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"m1"</span><span class="o">);</span>
        <span class="n">m2</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="c1">// 注意锁的释放</span>
        <span class="no">LOCK</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>synchronized 也是可重入锁，ReentrantLock有以下优点</p><ul><li>支持获取锁的超时时间<li>获取锁时可被打断<li>可设为公平锁<li>可以有不同的条件变量，即有多个waitSet，可以指定唤醒</ul><p>api</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// 默认非公平锁，参数传true 表示未公平锁</span>
<span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ReentrantLock</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
<span class="c1">// 尝试获取锁</span>
<span class="n">lock</span><span class="o">()</span>
<span class="c1">// 释放锁 应放在finally块中 必须执行到</span>
<span class="n">unlock</span><span class="o">()</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="c1">// 获取锁时可被打断,阻塞中的线程可被打断</span>
    <span class="no">LOCK</span><span class="o">.</span><span class="na">lockInterruptibly</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// 尝试获取锁 获取不到就返回false</span>
<span class="no">LOCK</span><span class="o">.</span><span class="na">tryLock</span><span class="o">()</span>
<span class="c1">// 支持超时时间 一段时间没获取到就返回false</span>
<span class="n">tryLock</span><span class="o">(</span><span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">)</span>
<span class="c1">// 指定条件变量 休息室 一个锁可以创建多个休息室</span>
<span class="nc">Condition</span> <span class="n">waitSet</span> <span class="o">=</span> <span class="no">ROOM</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
<span class="c1">// 释放锁  进入waitSet等待 释放后其他线程可以抢锁</span>
<span class="n">yanWaitSet</span><span class="o">.</span><span class="na">await</span><span class="o">()</span>
<span class="c1">// 唤醒具体休息室的线程 唤醒后 重写竞争锁</span>
<span class="n">yanWaitSet</span><span class="o">.</span><span class="na">signal</span><span class="o">()</span>
</pre></table></code></div></div><p>实例：一个线程输出a，一个线程输出b，一个线程输出c，abc按照顺序输出，连续输出5次</p><p>这个考的就是线程的通信，利用 wait()/notify()和控制变量可以实现，此处使用ReentrantLock即可实现该功能。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">AwaitSignal</span> <span class="n">awaitSignal</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AwaitSignal</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="c1">// 构建三个条件变量</span>
        <span class="nc">Condition</span> <span class="n">a</span> <span class="o">=</span> <span class="n">awaitSignal</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
        <span class="nc">Condition</span> <span class="n">b</span> <span class="o">=</span> <span class="n">awaitSignal</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
        <span class="nc">Condition</span> <span class="n">c</span> <span class="o">=</span> <span class="n">awaitSignal</span><span class="o">.</span><span class="na">newCondition</span><span class="o">();</span>
        <span class="c1">// 开启三个线程</span>
        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">awaitSignal</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">);</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">awaitSignal</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">);</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
            <span class="n">awaitSignal</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"c"</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="o">);</span>
        <span class="o">}).</span><span class="na">start</span><span class="o">();</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">awaitSignal</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="c1">// 先唤醒a</span>
            <span class="n">a</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="n">awaitSignal</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>


<span class="o">}</span>

<span class="kd">class</span> <span class="nc">AwaitSignal</span> <span class="kd">extends</span> <span class="nc">ReentrantLock</span> <span class="o">{</span>

    <span class="c1">// 循环次数</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">loopNumber</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">AwaitSignal</span><span class="o">(</span><span class="kt">int</span> <span class="n">loopNumber</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">loopNumber</span> <span class="o">=</span> <span class="n">loopNumber</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * @param print   输出的字符
     * @param current 当前条件变量
     * @param next    下一个条件变量
     */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">String</span> <span class="n">print</span><span class="o">,</span> <span class="nc">Condition</span> <span class="n">current</span><span class="o">,</span> <span class="nc">Condition</span> <span class="n">next</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loopNumber</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">lock</span><span class="o">();</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">try</span> <span class="o">{</span>
                    <span class="c1">// 获取锁之后等待</span>
                    <span class="n">current</span><span class="o">.</span><span class="na">await</span><span class="o">();</span>
                    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">print</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span>
                <span class="n">next</span><span class="o">.</span><span class="na">signal</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
                <span class="n">unlock</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></table></code></div></div><h2 id="死锁"><span class="mr-2">死锁</span><a href="#死锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>说到死锁,先举个例子，</p><p><img data-src="https://i.ibb.co/Dbgq2wS/a-HR0c-HM6-Ly9w-MS1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C85-MTVh-Yj-Rj-ZGE0.png" alt="" data-proofer-ignore></p><p>下面是代码实现</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="nc">Beer</span> <span class="n">beer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Beer</span><span class="o">();</span>
<span class="kd">static</span> <span class="nc">Story</span> <span class="n">story</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Story</span><span class="o">();</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">beer</span><span class="o">){</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"我有酒，给我故事"</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">story</span><span class="o">){</span>
                <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"小王开始喝酒讲故事"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">},</span><span class="s">"小王"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>

    <span class="k">new</span> <span class="nf">Thread</span><span class="o">(()</span> <span class="o">-&gt;{</span>
        <span class="kd">synchronized</span> <span class="o">(</span><span class="n">story</span><span class="o">){</span>
            <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"我有故事，给我酒"</span><span class="o">);</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
            <span class="kd">synchronized</span> <span class="o">(</span><span class="n">beer</span><span class="o">){</span>
                <span class="n">log</span><span class="o">.</span><span class="na">info</span><span class="o">(</span><span class="s">"老王开始喝酒讲故事"</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">},</span><span class="s">"老王"</span><span class="o">).</span><span class="na">start</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Beer</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Story</span><span class="o">{</span>
<span class="o">}</span>
</pre></table></code></div></div><p>死锁导致程序无法正常运行下去</p><p><img data-src="https://i.ibb.co/RBMH3Bp/a-HR0c-HM6-Ly9w-MS1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C9h-ODE3-ODRh-ODQ0.png" alt="" data-proofer-ignore></p><h2 id="java内存模型jmm"><span class="mr-2">Java内存模型(JMM)</span><a href="#java内存模型jmm" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>JMM 体现在以下三个方面</p><ul><li>原子性 保证指令不会受到上下文切换的影响<li>可见性 保证指令不会受到cpu缓存的影响<li>有序性 保证指令不会受并行优化的影响</ul><h3 id="可见性"><span class="mr-2">可见性</span><a href="#可见性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>停不下来的程序</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">boolean</span> <span class="n">run</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
    <span class="nc">Thread</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Thread</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="o">{</span>
        <span class="k">while</span> <span class="o">(</span><span class="n">run</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// ....</span>
        <span class="o">}</span>
    <span class="o">});</span>
    <span class="n">t</span><span class="o">.</span><span class="na">start</span><span class="o">();</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
   <span class="c1">// 线程t不会如预想的停下来</span>
    <span class="n">run</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span> 
<span class="o">}</span>
</pre></table></code></div></div><p><img data-src="https://i.ibb.co/y8ybwL6/a-HR0c-HM6-Ly9w-MS1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C9k-ODg4-MDA0-ZTBj.png" alt="" data-proofer-ignore></p><p>如上图所示，线程有自己的工作缓存，当主线程修改了变量并同步到主内存时，t线程没有读取到，所以程序停不下来</p><h3 id="有序性"><span class="mr-2">有序性</span><a href="#有序性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>JVM在不影响程序正确性的情况下可能会调整语句的执行顺序，该情况也称为 指令重排序</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>  <span class="kd">static</span> <span class="kt">int</span> <span class="n">i</span><span class="o">;</span>
  <span class="kd">static</span> <span class="kt">int</span> <span class="n">j</span><span class="o">;</span>
<span class="c1">// 在某个线程内执行如下赋值操作</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">...;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="o">...;</span>
  <span class="n">有可能将j先赋值</span>
</pre></table></code></div></div><h3 id="原子性"><span class="mr-2">原子性</span><a href="#原子性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>原子性大家应该比较熟悉，上述同步锁的synchronized代码块就是保证了原子性，就是一段代码是一个整体，原子性保证了线程安全，不会受到上下文切换的影响。</p><h3 id="volatile"><span class="mr-2">volatile</span><a href="#volatile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>该关键字解决了可见性和有序性，volatile通过内存屏障来实现的</p><ul><li><p>写屏障</p><p>会在对象写操作之后加写屏障，会对写屏障的之前的数据都同步到主存，并且保证写屏障的执行顺序在写屏障之前</p><li><p>读屏障</p><p>会在对象读操作之前加读屏障，会在读屏障之后的语句都从主存读，并保证读屏障之后的代码执行在读屏障之后</p></ul><p>注意： volatile不能解决原子性，即不能通过该关键字实现线程安全。</p><p>volatile应用场景：一个线程读取变量，另外的线程操作变量，加了该关键字后保证写变量后，读变量的线程可以及时感知。</p><h1 id="无锁-cas">无锁-cas</h1><p>cas （compare and swap) 比较并交换</p><p>为变量赋值时，从内存中读取到的值v，获取到要交换的新值n，执行 compareAndSwap()方法时，比较v和当前内存中的值是否一致，如果一致则将n和v交换，如果不一致，则自旋重试。</p><p>cas底层是cpu层面的，即不使用同步锁也可以保证操作的原子性。</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">private</span> <span class="nc">AtomicInteger</span> <span class="n">balance</span><span class="o">;</span>

<span class="c1">// 模拟cas的具体操作</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">withdraw</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">amount</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 获取当前值</span>
        <span class="kt">int</span> <span class="n">pre</span> <span class="o">=</span> <span class="n">balance</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="c1">// 进行操作后得到新值</span>
        <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">pre</span> <span class="o">-</span> <span class="n">amount</span><span class="o">;</span>
        <span class="c1">// 比较并设置成功 则中断 否则自旋重试</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">balance</span><span class="o">.</span><span class="na">compareAndSet</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">next</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>无锁的效率是要高于之前的锁的，由于无锁不会涉及线程的上下文切换</p><p>cas是乐观锁的思想，sychronized是悲观锁的思想</p><p>cas适合很少有线程竞争的场景，如果竞争很强，重试经常发生，反而降低效率</p><p>juc并发包下包含了实现了cas的原子类</p><ul><li>AtomicInteger/AtomicBoolean/AtomicLong<li>AtomicIntegerArray/AtomicLongArray/AtomicReferenceArray<li>AtomicReference/AtomicStampedReference/AtomicMarkableReference</ul><h2 id="atomicinteger"><span class="mr-2">AtomicInteger</span><a href="#atomicinteger" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">new</span> <span class="nc">AtomicInteger</span><span class="o">(</span><span class="n">balance</span><span class="o">)</span>
<span class="n">get</span><span class="o">()</span>
<span class="n">compareAndSet</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">next</span><span class="o">)</span>
<span class="c1">//        i.incrementAndGet() ++i</span>
<span class="c1">//        i.decrementAndGet() --i</span>
<span class="c1">//        i.getAndIncrement() i++</span>
<span class="c1">//        i.getAndDecrement() ++i</span>
 <span class="n">i</span><span class="o">.</span><span class="na">addAndGet</span><span class="o">()</span>
  <span class="c1">// 传入函数式接口 修改i</span>
  <span class="kt">int</span> <span class="nf">getAndUpdate</span><span class="o">(</span><span class="nc">IntUnaryOperator</span> <span class="n">updateFunction</span><span class="o">)</span>
  <span class="c1">// cas 的核心方法</span>
  <span class="n">compareAndSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">expect</span><span class="o">,</span> <span class="kt">int</span> <span class="n">update</span><span class="o">)</span>
</pre></table></code></div></div><h2 id="aba问题"><span class="mr-2">ABA问题</span><a href="#aba问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>cas存在ABA问题，即比较并交换时，如果原值为A,有其他线程将其修改为B，在有其他线程将其修改为A。</p><p>此时实际发生过交换，但是比较和交换由于值没改变可以交换成功</p><p>解决方式</p><p>AtomicStampedReference/AtomicMarkableReference</p><p>上面两个类解决ABA问题，原理就是为对象增加版本号,每次修改时增加版本号，就可以避免ABA问题</p><p>或者增加个布尔变量标识，修改后调整布尔变量值，也可以避免ABA问题</p><h1 id="线程池">线程池</h1><h2 id="线程池的介绍"><span class="mr-2">线程池的介绍</span><a href="#线程池的介绍" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>线程池是Java并发最重要的一个知识点，也是难点，是实际应用最广泛的。</p><p>线程的资源很宝贵，不可能无限的创建，必须要有管理线程的工具，线程池就是一种管理线程的工具，Java开发中经常有池化的思想，如 数据库连接池、Redis连接池等。</p><p>预先创建好一些线程，任务提交时直接执行，既可以节约创建线程的时间，又可以控制线程的数量。</p><p>线程池的好处</p><ul><li>降低资源消耗，通过池化思想，减少创建线程和销毁线程的消耗，控制资源<li>提高响应速度，任务到达时，无需创建线程即可运行<li>提供更多更强大的功能，可扩展性高</ul><p><img data-src="https://i.ibb.co/wSq6Dm5/a-HR0c-HM6-Ly9w-OS1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C85-ZGFh-MDM2-Nm-Y4.png" alt="" data-proofer-ignore></p><h2 id="线程池的构造方法"><span class="mr-2">线程池的构造方法</span><a href="#线程池的构造方法" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">,</span>
                          <span class="kt">int</span> <span class="n">maximumPoolSize</span><span class="o">,</span>
                          <span class="kt">long</span> <span class="n">keepAliveTime</span><span class="o">,</span>
                          <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">,</span>
                          <span class="nc">BlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">workQueue</span><span class="o">,</span>
                          <span class="nc">ThreadFactory</span> <span class="n">threadFactory</span><span class="o">,</span>
                          <span class="nc">RejectedExecutionHandler</span> <span class="n">handler</span><span class="o">)</span> <span class="o">{</span>
 
<span class="o">}</span>
</pre></table></code></div></div><p>构造器参数的意义</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">参数名<th style="text-align: left">参数意义<tbody><tr><td style="text-align: left">corePoolSize<td style="text-align: left">核心线程数<tr><td style="text-align: left">maximumPoolSize<td style="text-align: left">最大线程数<tr><td style="text-align: left">keepAliveTime<td style="text-align: left">救急线程的空闲时间<tr><td style="text-align: left">unit<td style="text-align: left">救急线程的空闲时间单位<tr><td style="text-align: left">workQueue<td style="text-align: left">阻塞队列<tr><td style="text-align: left">threadFactory<td style="text-align: left">创建线程的工厂，主要定义线程名<tr><td style="text-align: left">handler<td style="text-align: left">拒绝策略</table></div><h2 id="线程池案例"><span class="mr-2">线程池案例</span><a href="#线程池案例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>下面 我们通过一个实例来理解线程池的参数以及线程池的接收任务的过程</p><p><img data-src="https://i.ibb.co/Yhttnmq/a-HR0c-HM6-Ly9w-My1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C82-Yj-Ux-Nj-M1-OGI.png" alt="" data-proofer-ignore></p><p>如上图 银行办理业务。</p><ol><li>客户到银行时，开启柜台进行办理，柜台相当于线程，客户相当于任务，有两个是常开的柜台，三个是临时柜台。2就是核心线程数，5是最大线程数。即有两个核心线程<li>当柜台开到第二个后，都还在处理业务。客户再来就到排队大厅排队。排队大厅只有三个座位。<li>排队大厅坐满时，再来客户就继续开柜台处理，目前最大有三个临时柜台，也就是三个救急线程<li>此时再来客户，就无法正常为其 提供业务，采用拒绝策略来处理它们<li>当柜台处理完业务，就会从排队大厅取任务，当柜台隔一段空闲时间都取不到任务时，如果当前线程数大于核心线程数时，就会回收线程。即撤销该柜台。</ol><h2 id="线程池的状态"><span class="mr-2">线程池的状态</span><a href="#线程池的状态" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>线程池通过一个int变量的高3位来表示线程池的状态，低29位来存储线程池的数量</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">状态名称<th style="text-align: left">高三位<th style="text-align: left">接收新任务<th style="text-align: left">处理阻塞队列任务<th style="text-align: left">说明<tbody><tr><td style="text-align: left">Running<td style="text-align: left">111<td style="text-align: left">Y<td style="text-align: left">Y<td style="text-align: left">正常接收任务，正常处理任务<tr><td style="text-align: left">Shutdown<td style="text-align: left">0<td style="text-align: left">N<td style="text-align: left">Y<td style="text-align: left">不会接收任务,会执行完正在执行的任务,也会处理阻塞队列里的任务<tr><td style="text-align: left">stop<td style="text-align: left">1<td style="text-align: left">N<td style="text-align: left">N<td style="text-align: left">不会接收任务，会中断正在执行的任务,会放弃处理阻塞队列里的任务<tr><td style="text-align: left">Tidying<td style="text-align: left">10<td style="text-align: left">N<td style="text-align: left">N<td style="text-align: left">任务全部执行完毕，当前活动线程是0，即将进入终结<tr><td style="text-align: left">Termitted<td style="text-align: left">11<td style="text-align: left">N<td style="text-align: left">N<td style="text-align: left">终结状态</table></div><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// runState is stored in the high-order bits</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">RUNNING</span>    <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">SHUTDOWN</span>   <span class="o">=</span>  <span class="mi">0</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">STOP</span>       <span class="o">=</span>  <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TIDYING</span>    <span class="o">=</span>  <span class="mi">2</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">TERMINATED</span> <span class="o">=</span>  <span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="no">COUNT_BITS</span><span class="o">;</span>
</pre></table></code></div></div><h2 id="线程池的主要流程"><span class="mr-2">线程池的主要流程</span><a href="#线程池的主要流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>线程池创建、接收任务、执行任务、回收线程的步骤</p><ol><li>创建线程池后，线程池的状态是Running，该状态下才能有下面的步骤<li>提交任务时，线程池会创建线程去处理任务<li>当线程池的工作线程数达到corePoolSize时，继续提交任务会进入阻塞队列<li>当阻塞队列装满时，继续提交任务，会创建救急线程来处理<li>当线程池中的工作线程数达到maximumPoolSize时，会执行拒绝策略<li>当线程取任务的时间达到keepAliveTime还没有取到任务，工作线程数大于corePoolSize时，会回收该线程</ol><p>注意： 不是刚创建的线程是核心线程，后面创建的线程是非核心线程，线程是没有核心非核心的概念的，这是我长期以来的误解。</p><p>拒绝策略</p><ol><li>调用者抛出RejectedExecutionException (默认策略)<li>让调用者运行任务<li>丢弃此次任务<li>丢弃阻塞队列中最早的任务，加入该任务</ol><p>提交任务的方法</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre><span class="c1">// 执行Runnable</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">command</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullPointerException</span><span class="o">();</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isRunning</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">workQueue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">command</span><span class="o">))</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">recheck</span> <span class="o">=</span> <span class="n">ctl</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(!</span> <span class="n">isRunning</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">remove</span><span class="o">(</span><span class="n">command</span><span class="o">))</span>
            <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">workerCountOf</span><span class="o">(</span><span class="n">recheck</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
            <span class="n">addWorker</span><span class="o">(</span><span class="kc">null</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="o">(!</span><span class="n">addWorker</span><span class="o">(</span><span class="n">command</span><span class="o">,</span> <span class="kc">false</span><span class="o">))</span>
        <span class="n">reject</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
<span class="o">}</span>
<span class="c1">// 提交Callable</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="nc">Callable</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NullPointerException</span><span class="o">();</span>
   <span class="c1">// 内部构建FutureTask</span>
  <span class="nc">RunnableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">ftask</span> <span class="o">=</span> <span class="n">newTaskFor</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
  <span class="n">execute</span><span class="o">(</span><span class="n">ftask</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">ftask</span><span class="o">;</span>
<span class="o">}</span>
<span class="c1">// 提交Runnable,指定返回值</span>
<span class="kd">public</span> <span class="nc">Future</span><span class="o">&lt;?&gt;</span> <span class="n">submit</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">task</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NullPointerException</span><span class="o">();</span>
  <span class="c1">// 内部构建FutureTask</span>
  <span class="nc">RunnableFuture</span><span class="o">&lt;</span><span class="nc">Void</span><span class="o">&gt;</span> <span class="n">ftask</span> <span class="o">=</span> <span class="n">newTaskFor</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
  <span class="n">execute</span><span class="o">(</span><span class="n">ftask</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">ftask</span><span class="o">;</span>
<span class="o">}</span> 
<span class="c1">//  提交Runnable,指定返回值</span>
<span class="kd">public</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Future</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">submit</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">task</span><span class="o">,</span> <span class="no">T</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">task</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NullPointerException</span><span class="o">();</span>
   <span class="c1">// 内部构建FutureTask</span>
  <span class="nc">RunnableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">ftask</span> <span class="o">=</span> <span class="n">newTaskFor</span><span class="o">(</span><span class="n">task</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
  <span class="n">execute</span><span class="o">(</span><span class="n">ftask</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">ftask</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">protected</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">RunnableFuture</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">newTaskFor</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">,</span> <span class="no">T</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">FutureTask</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">runnable</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="execetors创建线程池"><span class="mr-2">Execetors创建线程池</span><a href="#execetors创建线程池" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote class="prompt-warning"><div><p>注意： 下面几种方式都不推荐使用</p></div></blockquote><h3 id="newfixedthreadpool"><span class="mr-2">newFixedThreadPool</span><a href="#newfixedthreadpool" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newFixedThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">nThreads</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="n">nThreads</span><span class="o">,</span> <span class="n">nThreads</span><span class="o">,</span>
                                  <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                                  <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>核心线程数 = 最大线程数 没有救急线程<li>阻塞队列无界 可能导致oom</ul><h3 id="newcachedthreadpool"><span class="mr-2">newCachedThreadPool</span><a href="#newcachedthreadpool" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newCachedThreadPool</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">,</span>
                                  <span class="mi">60L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">,</span>
                                  <span class="k">new</span> <span class="nc">SynchronousQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;());</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>核心线程数是0，最大线程数无限制 ，救急线程60秒回收<li>队列采用 SynchronousQueue 实现 没有容量，即放入队列后没有线程来取就放不进去<li>可能导致线程数过多，cpu负担太大</ul><h3 id="newsinglethreadexecutor"><span class="mr-2">newSingleThreadExecutor</span><a href="#newsinglethreadexecutor" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ExecutorService</span> <span class="nf">newSingleThreadExecutor</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">FinalizableDelegatedExecutorService</span>
        <span class="o">(</span><span class="k">new</span> <span class="nc">ThreadPoolExecutor</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span>
                                <span class="mi">0L</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">,</span>
                                <span class="k">new</span> <span class="nc">LinkedBlockingQueue</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;()));</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>核心线程数和最大线程数都是1，没有救急线程，无界队列 可以不停的接收任务<li>将任务串行化 一个个执行， 使用包装类是为了屏蔽修改线程池的一些参数 比如 corePoolSize<li>如果某线程抛出异常了，会重新创建一个线程继续执行<li>可能造成oom</ul><h3 id="newscheduledthreadpool"><span class="mr-2">newScheduledThreadPool</span><a href="#newscheduledthreadpool" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="nc">ScheduledExecutorService</span> <span class="nf">newScheduledThreadPool</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">ScheduledThreadPoolExecutor</span><span class="o">(</span><span class="n">corePoolSize</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>任务调度的线程池 可以指定延迟时间调用，可以指定隔一段时间调用</ul><h2 id="线程池的关闭"><span class="mr-2">线程池的关闭</span><a href="#线程池的关闭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="shutdown"><span class="mr-2">shutdown()</span><a href="#shutdown" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>会让线程池状态为shutdown，不能接收任务，但是会将工作线程和阻塞队列里的任务执行完 相当于优雅关闭</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">shutdown</span><span class="o">()</span> <span class="o">{</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">checkShutdownAccess</span><span class="o">();</span>
        <span class="n">advanceRunState</span><span class="o">(</span><span class="no">SHUTDOWN</span><span class="o">);</span>
        <span class="n">interruptIdleWorkers</span><span class="o">();</span>
        <span class="n">onShutdown</span><span class="o">();</span> <span class="c1">// hook for ScheduledThreadPoolExecutor</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="shutdownnow"><span class="mr-2">shutdownNow()</span><a href="#shutdownnow" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>会让线程池状态为stop， 不能接收任务，会立即中断执行中的工作线程，并且不会执行阻塞队列里的任务， 会返回阻塞队列的任务列表</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="nf">shutdownNow</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Runnable</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="o">;</span>
    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">mainLock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">mainLock</span><span class="o">;</span>
    <span class="n">mainLock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="n">checkShutdownAccess</span><span class="o">();</span>
        <span class="n">advanceRunState</span><span class="o">(</span><span class="no">STOP</span><span class="o">);</span>
        <span class="n">interruptWorkers</span><span class="o">();</span>
        <span class="n">tasks</span> <span class="o">=</span> <span class="n">drainQueue</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">mainLock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">tryTerminate</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">tasks</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="线程池的正确使用姿势"><span class="mr-2">线程池的正确使用姿势</span><a href="#线程池的正确使用姿势" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>线程池难就难在参数的配置，有一套理论配置参数</p><ul><li><p>cpu密集型 : 指的是程序主要发生cpu的运算</p><p>​核心线程数： CPU核心数+1</p><li><p>IO密集型: 远程调用RPC，操作数据库等，不需要使用cpu进行大量的运算。 大多数应用的场景</p><p>​核心线程数=核数*cpu期望利用率 *总时间/cpu运算时间</p></ul><p>但是基于以上理论还是很难去配置，因为cpu运算时间不好估算</p><p>实际配置大小可参考下表</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">cpu密集型<th style="text-align: left">io密集型<th style="text-align: left"> <tbody><tr><td style="text-align: left">线程数数量<td style="text-align: left">核数&lt;=x&lt;=核数*2<td style="text-align: left">核心数*50&lt;=x&lt;=核心数*100<tr><td style="text-align: left">队列长度<td style="text-align: left">y&gt;=100<td style="text-align: left">1&lt;=y&lt;=10</table></div><p><strong>1.线程池参数通过分布式配置，修改配置无需重启应用</strong></p><p>线程池参数是根据线上的请求数变化而变化的，最好的方式是 核心线程数、最大线程数 队列大小都是可配置的</p><p>主要配置 corePoolSize maxPoolSize queueSize</p><p>Java提供了可方法覆盖参数，线程池内部会处理好参数 进行平滑的修改</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCorePoolSize</span><span class="o">(</span><span class="kt">int</span> <span class="n">corePoolSize</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img data-src="https://i.ibb.co/BwCC9rG/a-HR0c-HM6-Ly9w-MS1qd-WVqa-W4u-Ynl0-ZWlt-Zy5jb20vd-G9z-LWNu-LWktaz-N1-MWZic-GZjc-C9l-Yj-Vk-OGRi-MDJl.png" alt="" data-proofer-ignore></p><p><strong>2.增加线程池的监控</strong></p><p><strong>3.io密集型可调整为先新增任务到最大线程数后再将任务放到阻塞队列</strong></p><p>代码 主要可重写阻塞队列 加入任务的方法</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">runnable</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">executor</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">RejectedExecutionException</span><span class="o">(</span><span class="s">"The task queue does not have executor!"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">final</span> <span class="nc">ReentrantLock</span> <span class="n">lock</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">lock</span><span class="o">;</span>
    <span class="n">lock</span><span class="o">.</span><span class="na">lock</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">currentPoolThreadSize</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="na">getPoolSize</span><span class="o">();</span>
       
        <span class="c1">// 如果提交任务数小于当前创建的线程数, 说明还有空闲线程,</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">executor</span><span class="o">.</span><span class="na">getTaskCount</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">currentPoolThreadSize</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 将任务放入队列中，让线程去处理任务</span>
            <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
        <span class="o">}</span>
		<span class="c1">// 核心改动</span>
        <span class="c1">// 如果当前线程数小于最大线程数，则返回 false ，让线程池去创建新的线程</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">currentPoolThreadSize</span> <span class="o">&lt;</span> <span class="n">executor</span><span class="o">.</span><span class="na">getMaximumPoolSize</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 否则，就将任务放入队列中</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">runnable</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
        <span class="n">lock</span><span class="o">.</span><span class="na">unlock</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><strong>4.绝策略 建议使用tomcat的拒绝策略(给一次机会)</strong></p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// tomcat的源码</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="nc">Runnable</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span> <span class="n">executor</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">executor</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="n">command</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">RejectedExecutionException</span> <span class="n">rx</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 捕获到异常后 在从队列获取，相当于重试1取不到任务 在执行拒绝任务</span>
            <span class="k">if</span> <span class="o">(</span> <span class="o">!(</span> <span class="o">(</span><span class="nc">TaskQueue</span><span class="o">)</span> <span class="n">executor</span><span class="o">.</span><span class="na">getQueue</span><span class="o">()).</span><span class="na">force</span><span class="o">(</span><span class="n">command</span><span class="o">)</span> <span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RejectedExecutionException</span><span class="o">(</span><span class="s">"Work queue full."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalStateException</span><span class="o">(</span><span class="s">"StandardThreadPool not started."</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>建议修改从队列取任务的方式： 增加超时时间，超时1分钟取不到在进行返回</p><div class="language-java highlighter-rouge"><div class="code-header"> <span data-label-text="Java"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">offer</span><span class="o">(</span><span class="no">E</span> <span class="n">e</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timeout</span><span class="o">,</span> <span class="nc">TimeUnit</span> <span class="n">unit</span><span class="o">){}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/software-development/'>Software Development</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >Java</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://t.me/share/url?url=https://optimus-xs.github.io/posts/java-multithreading-overview/&amp;text=Java 多线程概览 - Optimus-Xs&#39; Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://optimus-xs.github.io/posts/java-multithreading-overview/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/how-to-write-a-dockerfile-elegantly/">如何优雅的编写Dockerfile</a><li><a href="/posts/java-file-io-usage/">Java 文件 IO 使用方法</a><li><a href="/posts/jvm-gc-mechanism/">JVM 的垃圾回收机制</a><li><a href="/posts/docker-engine-installation-on-ubuntu/">在 Ubuntu 上安装 Dockers Engine 流程</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/devdairy/">DevDairy</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a> <a class="post-tag" href="/tags/geekdairy/">GeekDairy</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/java-collection-overview/"><div class="card-body"> <em class="timeago small" data-ts="1601710080" > 2020-10-03 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java 集合类概览</h3><div class="text-muted small"><p> Java集合框架 集合是java中存放对象的容器，存放于java.util包中。下图是java集合类的继承与实现关系： 框架图说明 所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 集合接口：6个接口（短虚线表示），表示...</p></div></div></a></div><div class="card"> <a href="/posts/why-autowired-not-recommended/"><div class="card-body"> <em class="timeago small" data-ts="1602220140" > 2020-10-09 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>为什么使用 @Autowired 提示不推荐</h3><div class="text-muted small"><p> @Autowired注解相信每个Spring开发者都不陌生了！ 但是当我们使用IDEA写代码的时候，经常会发现@Autowired注解下面是有小黄线的，我们把小鼠标悬停在上面，可以看到这个如下图所示的警告信息： 那么为什么IDEA会给出Field injection is not recommended这样的警告呢？ 下面带着这样的问题，一起来全面的了解下Spring中的三种注入方...</p></div></div></a></div><div class="card"> <a href="/posts/java-generics-usage/"><div class="card-body"> <em class="timeago small" data-ts="1602660480" > 2020-10-14 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Java 泛型使用方法</h3><div class="text-muted small"><p> 概述 泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 什么是泛型？为什么要使用泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/java-annotation-usage/" class="btn btn-outline-primary" prompt="上一篇"><p>Java 注解使用</p></a> <a href="/posts/java-concurrent-collection-overview/" class="btn btn-outline-primary" prompt="下一篇"><p>Java 并发集合概览</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Optimus-Xs">Optimus-Xs</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/devdairy/">DevDairy</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a> <a class="post-tag" href="/tags/geekdairy/">GeekDairy</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh-cn.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>

<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="prefer-datetime-locale" content="zh-cn"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="同源策略和实现跨域访问的方法" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="同源策略 同源策略定义 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。" /><meta property="og:description" content="同源策略 同源策略定义 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。" /><link rel="canonical" href="https://optimus-xs.github.io/posts/same-origin-policy-and-how-to-achieve-corss-origin-access/" /><meta property="og:url" content="https://optimus-xs.github.io/posts/same-origin-policy-and-how-to-achieve-corss-origin-access/" /><meta property="og:site_name" content="Optimus-Xs’ Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-04-07T14:25:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="同源策略和实现跨域访问的方法" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="VWHcsZQRCRLxZT171OOZpP1emj_N4gMlSvgq8UReWz4" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-04-07T14:25:00+08:00","datePublished":"2021-04-07T14:25:00+08:00","description":"同源策略 同源策略定义 1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。","headline":"同源策略和实现跨域访问的方法","mainEntityOfPage":{"@type":"WebPage","@id":"https://optimus-xs.github.io/posts/same-origin-policy-and-how-to-achieve-corss-origin-access/"},"url":"https://optimus-xs.github.io/posts/same-origin-policy-and-how-to-achieve-corss-origin-access/"}</script><title>同源策略和实现跨域访问的方法 | Optimus-Xs' Blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Optimus-Xs' Blog"><meta name="application-name" content="Optimus-Xs' Blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/miTu.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Optimus-Xs' Blog</a></div><div class="site-subtitle font-italic">「Think Different」</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Optimus-Xs" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['Wenlong.Zuo','outlook.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>同源策略和实现跨域访问的方法</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>同源策略和实现跨域访问的方法</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/Optimus-Xs">Optimus-Xs</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1617776700" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2021-04-07 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4050 字"> <em>22 分钟</em>阅读</span></div></div></div><div class="post-content"><h1 id="同源策略">同源策略</h1><h2 id="同源策略定义"><span class="mr-2">同源策略定义</span><a href="#同源策略定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p><p>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”</p><p>如果两个 URL 的 protocol、port (en-US) (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。</p><p>所谓同源是指：域名、协议、端口相同。</p><p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说 Web 是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p><p>它的核心就在于它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。</p><p>下表给出了与 URL http://example.company.com/dir/page.html 的源进行对比的示例:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">URL<th style="text-align: left">结果<th style="text-align: left">原因<tbody><tr><td style="text-align: left">http://example.company.com/dir2/other.html<td style="text-align: left">同源<td style="text-align: left">只有路径不同<tr><td style="text-align: left">http://example.company.com/dir/inner/another.html<td style="text-align: left">同源<td style="text-align: left">只有路径不同<tr><td style="text-align: left">https://example.company.com/secure.html<td style="text-align: left">失败<td style="text-align: left">协议不同<tr><td style="text-align: left">http://example.company.com:81/dir/etc.html<td style="text-align: left">失败<td style="text-align: left">端口不同 ( http:// 默认端口是80)<tr><td style="text-align: left">http://news.company.com/dir/other.html<td style="text-align: left">失败<td style="text-align: left">主机不同</table></div><p>随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。</p><ul><li>Cookie、LocalStorage 和 IndexDB 无法读取。<li>DOM 无法获得。<li>AJAX 请求不能发送。</ul><h2 id="为什么使用同源策略"><span class="mr-2">为什么使用同源策略</span><a href="#为什么使用同源策略" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>因为存在浏览器同源策略，所以才会有跨域问题。那么浏览器是出于何种原因会有跨域的限制呢。其实不难想到，跨域限制主要的目的就是为了用户的上网安全。</p><p>如果浏览器没有同源策略，会存在什么样的安全问题呢。下面从 DOM 同源策略和 XMLHttpRequest 同源策略来举例说明：</p><p>如果没有 DOM 同源策略，也就是说不同域的 iframe 之间可以相互访问，那么黑客可以这样进行攻击：</p><ul><li>做一个假网站，里面用 iframe 嵌套一个银行网站 http://mybank.com。<li>把 iframe 宽高啥的调整到页面全部，这样用户进来除了域名，别的部分和银行的网站没有任何差别。<li>这时如果用户输入账号密码，我们的主网站可以跨域访问到 http://mybank.com 的 dom 节点，就可以拿到用户的账户密码了。</ul><p>如果没有 XMLHttpRequest 同源策略，那么黑客可以进行 CSRF（跨站请求伪造） 攻击：</p><ul><li>用户登录了自己的银行页面 http://mybank.com，http://mybank.com 向用户的 cookie 中添加用户标识。<li>用户浏览了恶意页面 http://evil.com，执行了页面中的恶意 AJAX 请求代码。<li>http://evil.com 向 http://mybank.com 发起 AJAX HTTP 请求，请求会默认把 http://mybank.com 对应 cookie 也同时发送过去。<li>银行页面从发送的 cookie 中提取用户标识，验证用户无误，response 中返回请求数据。此时数据就泄露了。<li>而且由于 Ajax 在后台执行，用户无法感知这一过程。</ul><p>因此，有了浏览器同源策略，我们才能更安全的上网。</p><h1 id="跨域访问实现">跨域访问实现</h1><h2 id="cors"><span class="mr-2">CORS</span><a href="#cors" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>CORS的全称是 Cross-Origin Resource Sharing 跨域资源共享。</p><p>是浏览器为 AJAX 请求设置的一种跨域机制，让其可以在服务端允许的情况下进行跨域访问。主要通过 HTTP 响应头来告诉浏览器服务端是否允许当前域的脚本进行跨域访问。</p><p>跨域资源共享将 AJAX 请求分成了两类：</p><ul><li>简单请求<li>非简单请求</ul><h3 id="简单请求"><span class="mr-2">简单请求</span><a href="#简单请求" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>简单请求需要符合以下特征</p><ul><li>请求方法为 GET、POST、HEAD<li><p>请求头只能使用下面的字段：</p><ul><li>Accept 浏览器能够接受的响应内容类型。<li>Accept-Language浏览器能够接受的自然语言列表。<li>Content-Type 请求对应的类型，只限于 text/plain、multipart/form-data、application/x-www-form-urlencoded。<li>Content-Language浏览器希望采用的自然语言。<li>Save-Data浏览器是否希望减少数据传输量。</ul></ul><p><strong>简单请求流程如下:</strong></p><p>浏览器发出简单请求的时候，会在请求头部增加一个 Origin 字段，对应的值为当前请求的源信息。</p><p>当服务端收到请求后，会根据请求头字段 Origin 做出判断后返回相应的内容。</p><p>浏览器收到响应报文后会根据响应头部字段 Access-Control-Allow-Origin 进行判断，这个字段值为服务端允许跨域请求的源，其中通配符 * 表示允许所有跨域请求。如果头部信息没有包含 Access-Control-Allow-Origin 字段或者响应的头部字段 Access-Control-Allow-Origin 不允许当前源的请求，则会抛出错误。</p><h3 id="非简单请求"><span class="mr-2">非简单请求</span><a href="#非简单请求" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>只要不符合上述简单请求的特征，会变成非简单请求，浏览器在处理非简单的请求时，浏览器会先发出一个预检请求（Preflight）。这个预检请求为 OPTIONS 方法，并会添加了 1 个请求头部字段 Access-Control-Request-Method，值为跨域请求所使用的请求方法。</p><p>在服务端收到预检请求后，除了在响应头部添加 Access-Control-Allow-Origin 字段之外，至少还会添加 Access-Control-Allow-Methods 字段来告诉浏览器服务端允许的请求方法，并返回 204 状态码。</p><p>服务端还根据浏览器的 Access-Control-Request-Headers 字段回应了一个 Access-Control-Allow-Headers 字段，来告诉浏览器服务端允许的请求头部字段。</p><p>浏览器得到预检请求响应的头部字段之后，会判断当前请求服务端是否在服务端许可范围之内，如果在则继续发送跨域请求，反之则直接报错。</p><p><strong>CORS常用头部字段</strong></p><ul><li>origin</ul><p>请求首部字段, Origin 指示了请求来自于哪个站点, 包括协议、域名、端口、不包括路径部分 在不携带凭证的情况下，可以使是一个*，表示接受任意域名的请求</p><ul><li>Access-Control-Allow-Origin</ul><p>响应头，用来标识允许哪个域的请求</p><ul><li>Access-Control-Allow-Methods</ul><p>响应头，用来标识允许哪些请求方法被允许</p><ul><li>access-control-allow-headers</ul><p>响应首部， 用于预检请求中，列出了将会在正式请求的允许携带的请求头信息。</p><ul><li>Access-Control-Expose-Headers</ul><p>响应头，用来告诉浏览器，服务器可以自定义哪些字段暴露给浏览器</p><ul><li>Access-Control-Allow-Credentials</ul><p>是否允许携带Credentials,Credentials可以是 cookies, authorization headers 或 TLS client certificates。</p><ul><li>Access-Control-Max-Age</ul><p>预检请求的缓存时长</p><h3 id="cors-示例"><span class="mr-2">CORS 示例</span><a href="#cors-示例" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>CORS 示例参考：<a href="/posts/springboot-cors-config/">SpringBoot 配置 CORS 跨域请求的三种方法</a></p><p>CORS 优点:</p><ul><li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护。<li>支持所有类型的 HTTP 请求。</ul><p>CORS 缺点:</p><ul><li>存在兼容性问题，特别是 IE10 以下的浏览器。<li>第一次发送非简单请求时会多一次请求。</ul><h2 id="jsonp"><span class="mr-2">JSONP</span><a href="#jsonp" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>JSONP（JSON with Padding）的意思就是用 JSON 数据来填充。</p><p>怎么填充呢？</p><p>结合它的实现方式可以知道，就是把 JSON 数填充到一个回调函数中。是利用 script 标签跨域引用 js 文件不会受到浏览器同源策略的限制,具有天然跨域性。</p><p>假设我们要在 http://www.a.com 中向 http://www.b.com 请求数据。</p><ol><li>全局声明一个用来处理返回值的函数 fn，该函数参数为请求的返回结果。<div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</pre></table></code></div></div><li>将函数名与其他参数一并写入 URL 中<div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://www.b.com?callback=fn&amp;params=...</span><span class="dl">'</span><span class="p">;</span>
</pre></table></code></div></div><li>动态创建一个 script 标签，把 URL 赋值给 script 的 src属性。<div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">script</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">script</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">script</span><span class="p">.</span><span class="nx">setAttribute</span><span class="p">(</span><span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">,</span><span class="dl">"</span><span class="s2">text/javascript</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">script</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">script</span><span class="p">);</span>
</pre></table></code></div></div><li>当服务器接收到请求后，解析 URL 参数并进行对应的逻辑处理，得到结果后将其写成回调函数的形式并返回给浏览器。<div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nx">fn</span><span class="p">({</span>
  <span class="na">list</span><span class="p">:</span> <span class="p">[],</span>
  <span class="p">...</span>
<span class="p">})</span>
</pre></table></code></div></div><li>在浏览器收到请求返回的 js 脚本之后会立即执行文件内容，即可获取到服务端返回的数据。</ol><p>JSONP 虽然实现了跨域请求，但也存在以下的几个问题：</p><ul><li>只能发送 GET 请求，限制了参数大小和类型。<li>请求过程无法终止，导致弱网络下处理超时请求比较麻烦。<li>无法捕获服务端返回的异常信息。</ul><h2 id="websocket"><span class="mr-2">Websocket</span><a href="#websocket" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Websocket 是 HTML5 规范提出的一个应用层的全双工协议，适用于浏览器与服务器进行实时通信场景。</p><p>全双工通信传输的一个术语，这里的“工”指的是通信方向。</p><p>“双工”是指从客户端到服务端，以及从服务端到客户端两个方向都可以通信，“全”指的是通信双方可以同时向对方发送数据。与之相对应的还有半双工和单工，半双工指的是双方可以互相向对方发送数据，但双方不能同时发送，单工则指的是数据只能从一方发送到另一方。</p><p>下面是一段简单的示例代码。在 a 网站直接创建一个 WebSocket 连接，连接到 b 网站即可，然后调用 WebScoket 实例 ws 的 send() 函数向服务端发送消息，监听实例 ws 的 onmessage 事件得到响应内容。</p><div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">let</span> <span class="nx">ws</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="dl">"</span><span class="s2">ws://b.com</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
<span class="err"> </span> <span class="c1">// ws.send(...);</span>
<span class="p">}</span>
<span class="nx">ws</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">){</span>
<span class="err"> </span> <span class="c1">// console.log(e.data);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="请求代理"><span class="mr-2">请求代理</span><a href="#请求代理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>我们知道浏览器有同源策略的安全限制，但是服务器没有限制，所以我们可以利用服务器进行请求转发。</p><p>以 webpack 为例，利用 webpack-dev-server 配置代理, 当浏览器发起前缀为 /api 的请求时都会被转发到 http://localhost:3000 服务器，代理服务器将获取到响应返回给浏览器。对于浏览器而言还是请求当前网站，但实际上已经被服务端转发。</p><div class="language-conf highlighter-rouge"><div class="code-header"> <span data-label-text="Conf"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>// <span class="n">webpack</span>.<span class="n">config</span>.<span class="n">js</span>
<span class="n">module</span>.<span class="n">exports</span> = {
  //...
  <span class="n">devServer</span>: {
    <span class="n">proxy</span>: {
      <span class="s1">'/api'</span>: <span class="s1">'http://localhost:3000'</span>
    }
  }
};

// 使用 <span class="n">Nginx</span> 作为代理服务器
<span class="n">location</span> /<span class="n">api</span> {
    <span class="n">proxy_pass</span>   <span class="n">http</span>://<span class="n">localhost</span>:<span class="m">3000</span>;
}
</pre></table></code></div></div><h2 id="图像-ping-跨域"><span class="mr-2">图像 Ping 跨域</span><a href="#图像-ping-跨域" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>由于 img 标签不受浏览器同源策略的影响，允许跨域引用资源。因此可以通过 img 标签的 src 属性进行跨域，这也就是图像 Ping 跨域的基本原理。</p><p>直接通过下面的例子来说明图像 Ping 实现跨域的流程：</p><div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">img</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Image</span><span class="p">();</span>

<span class="c1">// 通过 onload 及 onerror 事件可以知道响应是什么时候接收到的，但是不能获取响应文本</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="nx">img</span><span class="p">.</span><span class="nx">onerror</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Done!</span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 请求数据通过查询字符串形式发送</span>
<span class="nx">img</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://www.example.com/test?name=testscript</span><span class="dl">'</span><span class="p">;</span>
</pre></table></code></div></div><p>img标签跨域优点:</p><ul><li>用于实现跟踪用户点击页面或动态广告曝光次数有较大的优势。</ul><p>img标签跨域缺点:</p><ul><li>只支持 GET 请求。<li>只能浏览器与服务器的单向通信，因为浏览器不能访问服务器的响应文本。</ul><h2 id="页面跨域解决方案"><span class="mr-2">页面跨域解决方案</span><a href="#页面跨域解决方案" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>请求跨域之外，页面之间也会有跨域需求，例如使用 iframe 时父子页面之间进行通信。常用方案如下：</p><ul><li>postMessage<li>document.domain<li>window.name(不常用)<li>location.hash + iframe(不常用)</ul><h3 id="postmessage"><span class="mr-2">postMessage</span><a href="#postmessage" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>window.postMessage 是 HTML5 推出一个新的函数，用来实现父子页面之间通信，而且不论这两个页面是否同源。</p><p>以 https://test.com 和 https://a.test.com 为例子:</p><div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// https://test.com</span>
<span class="kd">let</span> <span class="nx">child</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="dl">'</span><span class="s1">https://a.test.com</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">child</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">https://a.test.com</span><span class="dl">'</span><span class="p">);</span>
</pre></table></code></div></div><p>上面的代码通过 window.open() 函数打开了子页面，然后调用 child.postMessage() 函数发送了字符串数据hello给子页面。</p><p>在子页面中，只需要监听message事件即可得到父页面的数据。代码如下：</p><div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// https://a.test.com</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">message</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
<span class="err"> </span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span> <span class="c1">// hello</span>
<span class="p">},</span><span class="kc">false</span><span class="p">);</span>
</pre></table></code></div></div><p>子页面发送数据时则要通过 window.opener 对象来调用 postMessage() 函数.</p><div class="language-js highlighter-rouge"><div class="code-header"> <span data-label-text="JavaScript"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// https://a.test.com</span>
<span class="nb">window</span><span class="p">.</span><span class="nx">opener</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">https://test.com</span><span class="dl">'</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="documentdomain"><span class="mr-2">document.domain</span><a href="#documentdomain" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>domain 属性可返回下载当前文档的服务器域名。通过修改 document.domain 的值来进行跨域, 这种情况适合主域名相同，子域名不同的页面。</p><p>我们以 https://www.test.com/parent.html，在这个页面里面有一个 iframe，其 src 是 http://a.test.com/child.html。</p><p>这时只要把 https://www.test.com/parent.html 和 http://a.test.com/child.html 这两个页面的 document.domain 都设成相同的域名，那么父子页面之间就可以进行跨域通信了，同时还可以共享 cookie。</p><p>但要注意的是，只能把 document.domain 设置成更高级的父域才有效果，例如在 ·http://a.test.com/child.html 中可以将 document.domain 设置成 test.com</p><h3 id="windowname"><span class="mr-2">window.name</span><a href="#windowname" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>name 属性可设置或返回存放窗口的名称的一个字符串，name值在不同的页面（包括域名改变）加载后依旧存在。</p><p>我们准备三个页面：</p><ul><li>https://localhost:3000/a.html<li>https://localhost:3000/b.html<li>https://localhost:4000/c.html a页面和 b 页面在相同域下，c页面在另一个域下。</ul><p>我们想a和 c进行通讯，必然涉及到跨域, 通过下面的代码，改变window.name的值来实现跨域。</p><p>整体实现思路， b.html其实只是个中间代理页面。</p><ul><li>a.html的 iframe先加载c.html页面，此时c.html设置了 window.name = ‘test’。<li>在c.html加载完毕，设置iframe的src为b.html, 由于a.html和b.html在同域，且window.name在域名改变页面从新加载后值不变，实现跨域。</ul><div file="a.html" class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="a.html"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- https://localhost:3000/a.html --&gt;</span>

<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">'https://localhost:4000/c.html'</span> <span class="na">onload=</span><span class="s">"onload()"</span> <span class="na">id=</span><span class="s">"iframe"</span><span class="nt">&gt;&lt;/iframe&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="c1">// iframe 加载完会调用 iframe， 防止src 改变出现死循环。</span>
        <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span> <span class="kc">true</span>
        <span class="kd">function</span> <span class="nx">onload</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">{</span>
                <span class="kd">let</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">iframe</span><span class="dl">'</span><span class="p">)</span>
                <span class="nx">iframe</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">https://localhost:3000/b.html</span><span class="dl">'</span>
                <span class="nx">first</span> <span class="o">=</span> <span class="kc">false</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">iframe</span><span class="p">.</span><span class="nx">contentWindow</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// 'test'</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></table></code></div></div><div file="c.html" class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="c.html"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c">&lt;!-- https://localhost:4000/c.html --&gt;</span>
<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">test</span><span class="dl">'</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
</pre></table></code></div></div><h3 id="locationhash"><span class="mr-2">location.hash</span><a href="#locationhash" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。</p><p>我们准备三个页面：</p><ul><li>https://localhost:3000/a.html<li>https://localhost:3000/b.html<li>https://localhost:4000/c.html a页面和 b 页面在相同域下，c页面在另一个域下。</ul><p>我们想a和 c进行通讯，必然涉及到跨域, 通过下面的代码，改变window.location.hash的值来实现跨域。</p><div file="a.html" class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="a.html"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="c">&lt;!-- 通过 hash 给 c.html 传值 --&gt;</span>
    <span class="nt">&lt;iframe</span> <span class="na">src=</span><span class="s">'https://localhost:4000/c.html#test'</span> <span class="na">id=</span><span class="s">"iframe"</span><span class="nt">&gt;&lt;/iframe&gt;</span>
    <span class="nt">&lt;script&gt;</span> 
        <span class="c1">//  监听 hash 变化</span>
        <span class="nb">window</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">hashchange</span><span class="dl">'</span><span class="p">,()</span><span class="o">=&gt;</span><span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></table></code></div></div><div file="b.html" class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="b.html"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script&gt;</span>
     <span class="c1">// 由于 c 加载的 b 页面，所以，window.parent 是 c 页面</span>
     <span class="c1">// c 页面的 parent 是 a 页面，然后设置a页面的 hash 值</span>
      <span class="nb">window</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">parent</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span> <span class="o">=</span>  <span class="nx">location</span><span class="p">.</span><span class="nx">hash</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></table></code></div></div><div file="c.html" class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="c.html"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;script&gt;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">location</span><span class="p">.</span><span class="nx">hash</span><span class="p">)</span>
        <span class="kd">let</span> <span class="nx">iframe</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">iframe</span><span class="dl">'</span><span class="p">)</span>
        <span class="nx">iframe</span><span class="p">.</span><span class="nx">src</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">https://localhost:3000/b.html#test_one</span><span class="dl">'</span>
        <span class="nb">document</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">iframe</span><span class="p">)</span>
    <span class="nt">&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</pre></table></code></div></div><h1 id="总结">总结</h1><p>在请求资源进行跨域是，推荐使用 CORS 和 JSONP。</p><p>在页面资源跨域时推荐使用postMessage 和 document.domain。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/software-development/'>Software Development</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/internet-security/" class="post-tag no-text-decoration" >Internet Security</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://t.me/share/url?url=https://optimus-xs.github.io/posts/same-origin-policy-and-how-to-achieve-corss-origin-access/&amp;text=同源策略和实现跨域访问的方法 - Optimus-Xs&#39; Blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https://optimus-xs.github.io/posts/same-origin-policy-and-how-to-achieve-corss-origin-access/" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/how-to-write-a-dockerfile-elegantly/">如何优雅的编写Dockerfile</a><li><a href="/posts/java-file-io-usage/">Java 文件 IO 使用方法</a><li><a href="/posts/jvm-gc-mechanism/">JVM 的垃圾回收机制</a><li><a href="/posts/docker-engine-installation-on-ubuntu/">在 Ubuntu 上安装 Dockers Engine 流程</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/devdairy/">DevDairy</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a> <a class="post-tag" href="/tags/geekdairy/">GeekDairy</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/4-protocols-for-enhanced-domain-name-security/"><div class="card-body"> <em class="timeago small" data-ts="1653223620" > 2022-05-22 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>4种强化域名安全的协议</h3><div class="text-muted small"><p> 传统的 DNS 有啥问题 传统的 DNS 是一个【比较古老】的协议。最早的草案可以追溯到1983年。1987年定稿之后，基本上没啥变化。 设计 DNS 的时候，互联网基本上还是个玩具。那年头的互联网协议，压根儿都没考虑安全性，DNS 当然也不例外。所以 DNS 的交互过程全都是【明文】滴，既无法做到“保密性”，也无法实现“完整性”。 缺乏“保密性”就意味着——任何一个能【监视】你上网流量...</p></div></div></a></div><div class="card"> <a href="/posts/redis-cache-avalanche-breakdown-penetration/"><div class="card-body"> <em class="timeago small" data-ts="1645260660" > 2022-02-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Redis 缓存雪崩、击穿、穿透</h3><div class="text-muted small"><p> 缓存雪崩 雪崩定义 举个简单的例子: 如果所有首页的Key失效时间都是12小时，中午12点刷新的，假设有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能DBA都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个...</p></div></div></a></div><div class="card"> <a href="/posts/linux-golang-installation/"><div class="card-body"> <em class="timeago small" data-ts="1648913520" > 2022-04-02 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Linux Golang 安装流程</h3><div class="text-muted small"><p> Go，通常被称为 golang，它是一门由 Google 创建的现代化的开源编程语言，它允许你构建实时并且高效的应用。 很多流行的应用程序，例如 Kubernetes，Docker，Prometheus 和 Terraform，都是使用 Go 来编写的。 这篇教程讲解如何在 Ubuntu 20.04 上下载和安装 Go。 下载 Go 压缩包 在写这篇文章的时候，Go 的最新版为 1.1...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/springboot-cors-config/" class="btn btn-outline-primary" prompt="上一篇"><p>SpringBoot 配置 CORS 跨域请求的三种方法</p></a> <a href="/posts/integrate-redis-in-springboot/" class="btn btn-outline-primary" prompt="下一篇"><p>在 SpringBoot 中集成 Redis</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Optimus-Xs">Optimus-Xs</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">Java</a> <a class="post-tag" href="/tags/spring/">Spring</a> <a class="post-tag" href="/tags/devdairy/">DevDairy</a> <a class="post-tag" href="/tags/data-structure/">Data Structure</a> <a class="post-tag" href="/tags/%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/">安装流程</a> <a class="post-tag" href="/tags/geekdairy/">GeekDairy</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/network/">Network</a> <a class="post-tag" href="/tags/redis/">Redis</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh-cn.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>

<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://optimus-xs.github.io/</id><title>Optimus-Xs' Blog</title><subtitle>A programmer &amp; geek's blog, update some funny project logs and dev tech articles irregularly</subtitle> <updated>2023-05-02T16:37:30+08:00</updated> <author> <name>Optimus-Xs</name> <uri>https://optimus-xs.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://optimus-xs.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://optimus-xs.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator> <rights> © 2023 Optimus-Xs </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>如何优雅的编写Dockerfile</title><link href="https://optimus-xs.github.io/posts/how-to-write-a-dockerfile-elegantly/" rel="alternate" type="text/html" title="如何优雅的编写Dockerfile" /><published>2022-09-16T20:07:00+08:00</published> <updated>2023-05-02T16:36:55+08:00</updated> <id>https://optimus-xs.github.io/posts/how-to-write-a-dockerfile-elegantly/</id> <content src="https://optimus-xs.github.io/posts/how-to-write-a-dockerfile-elegantly/" /> <author> <name>Optimus-Xs</name> </author> <category term="Software Development" /> <summary> 容器需要从Dockerfile开始，本文将介绍如何写出一个优雅的Dockerfile文件。 Docker容器 容器的特点 我们都知道容器就是一个标准的软件单元，它有以下特点： 随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。 高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置CPU和内存的使用率，进而更好地利用服务器的计算资源。 快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。 轻量：容器是进程级的资源隔离，而虚拟机是操作系统级的资源隔离，所以Docker容器相对于虚拟机来说可以节省更多的资源开销，因为Docker容器不再需要GuestOS这一层操作系统了。 快速：容器的启动和创建无需启动GuestOS，可以实现秒级甚至毫秒级的启动... </summary> </entry> <entry><title>Portainer 在 VPS 的部署流程</title><link href="https://optimus-xs.github.io/posts/deploy-portainer-in-vps/" rel="alternate" type="text/html" title="Portainer 在 VPS 的部署流程" /><published>2022-07-23T21:07:00+08:00</published> <updated>2022-07-23T21:07:00+08:00</updated> <id>https://optimus-xs.github.io/posts/deploy-portainer-in-vps/</id> <content src="https://optimus-xs.github.io/posts/deploy-portainer-in-vps/" /> <author> <name>Optimus-Xs</name> </author> <category term="Tech Projects" /> <summary> 介绍 Portainer 是一个轻量级的管理 UI ，可让你轻松管理不同的 Docker 环境（Docker 主机或 Swarm 群集）。它由可在任何 Docker 引擎上运行的单个容器组成 Portainer 由两个元素组成，Portainer Server和Portainer Agent 。这两个元素在 Docker 引擎上作为轻量级 Docker 容器运行。本文档将帮助您在 Linux 环境中安装 Portainer Server 容器。 部署Portainer 部署前置条件 最新版本的 Docker 已安装并运行 在要安装 Portainer 的服务器实上启用 sudo 权限 默认情况下，Portainer Server 将通过 port 公开 UI，9443并通过 port 公开 TCP 隧道服务器8000。后者是可选的，仅在计划将边缘计算功能与边缘代理一起使用时才需... </summary> </entry> <entry><title>Proxmox VE直通硬盘</title><link href="https://optimus-xs.github.io/posts/passthrough-hard-drive-in-proxmox-ve/" rel="alternate" type="text/html" title="Proxmox VE直通硬盘" /><published>2022-06-14T14:37:00+08:00</published> <updated>2022-06-14T14:37:00+08:00</updated> <id>https://optimus-xs.github.io/posts/passthrough-hard-drive-in-proxmox-ve/</id> <content src="https://optimus-xs.github.io/posts/passthrough-hard-drive-in-proxmox-ve/" /> <author> <name>Optimus-Xs</name> </author> <category term="Tech Projects" /> <summary> 使用PVE有时为了方便，需要将硬盘直通, PVE系统直通硬盘有两种方式，方法一命令操作，直通单块硬盘；方法二添加 PCI设备，直通 SATA Controller(SATA 控制器)。 全盘映射 查找磁盘ID 进入Proxmox VE(PVE)系统的SSH，或直接进入PVE管理网页Shell 输入命令： ls -l /dev/disk/by-id/ lrwxrwxrwx 1 root root 9 Jun 12 09:36 ata-GALAX_TA1D0240A_305D0********0279966 -&amp;gt; ../../sda lrwxrwxrwx 1 root root 10 Jun 12 09:36 ata-GALAX_TA1D0240A_305D0********0279966-part1 -&amp;gt; ../../sda1 lrwxrwxrwx 1 root... </summary> </entry> <entry><title>4种强化域名安全的协议</title><link href="https://optimus-xs.github.io/posts/4-protocols-for-enhanced-domain-name-security/" rel="alternate" type="text/html" title="4种强化域名安全的协议" /><published>2022-05-22T20:47:00+08:00</published> <updated>2022-05-22T20:47:00+08:00</updated> <id>https://optimus-xs.github.io/posts/4-protocols-for-enhanced-domain-name-security/</id> <content src="https://optimus-xs.github.io/posts/4-protocols-for-enhanced-domain-name-security/" /> <author> <name>Optimus-Xs</name> </author> <category term="Bottom Layer Knowledge" /> <summary> 传统的 DNS 有啥问题 传统的 DNS 是一个【比较古老】的协议。最早的草案可以追溯到1983年。1987年定稿之后，基本上没啥变化。 设计 DNS 的时候，互联网基本上还是个玩具。那年头的互联网协议，压根儿都没考虑安全性，DNS 当然也不例外。所以 DNS 的交互过程全都是【明文】滴，既无法做到“保密性”，也无法实现“完整性”。 缺乏“保密性”就意味着——任何一个能【监视】你上网流量的人，都可以【看到】你查询了哪些域名。直接引发的问题就是隐私风险。 缺乏“完整性”就意味着——任何一个能【修改】你上网流量的人，都可以【篡改】你的查询结果。直接引发的问题就是“DNS 欺骗”（也叫“DNS 污染”或“DNS 缓存投毒”） 为了解决传统 DNS 的这些弊端，后来诞生了好几个网络协议，以强化域名系统的安全性 DNSSEC 历史 这玩意儿是“Domain Name System S... </summary> </entry> <entry><title>Gin 中的 BasicAuth授权认证中间件使用</title><link href="https://optimus-xs.github.io/posts/the-basicauth-authorization-middleware-in-gin/" rel="alternate" type="text/html" title="Gin 中的 BasicAuth授权认证中间件使用" /><published>2022-05-14T20:35:00+08:00</published> <updated>2022-05-14T20:35:00+08:00</updated> <id>https://optimus-xs.github.io/posts/the-basicauth-authorization-middleware-in-gin/</id> <content src="https://optimus-xs.github.io/posts/the-basicauth-authorization-middleware-in-gin/" /> <author> <name>Optimus-Xs</name> </author> <category term="Software Development" /> <summary> 什么是BasicAuth 是一种开放平台认证方式，简单的说就是需要你输入用户名和密码才能继续访问。 在单路由中使用 如果需要针对单个路由使用，在要在单路由中注册BasicAuth 中间件即可。 // 使用BasicAuth中间件 func main(){ engine := gin.Default() // 设置账号和密码，key:代表账号,value:代表密码 ginAccounts := gin.Accounts{ "user":"password", "abc":"123", } // 注册路由和中间件 engine.GET("/test",gin.BasicAuth(ginAccounts), func(context *gin.Context) { // 获取中间件BasicAuth user := context.MustGet(gin.... </summary> </entry> </feed>
